<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.18.0 + Helium Theme" />
    <title>Libretto Basics</title>
    
    
    
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    
    <link rel="stylesheet" type="text/css" href="helium/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="helium/laika-helium.css" />
    <script src="helium/laika-helium.js"></script>
    
    
    <script> /* for avoiding page load transitions */ </script>
  </head>

  <body>

    <header id="top-bar">

      <div class="row">
        <a id="nav-icon">
          <i class="icofont-laika" title="Navigation">&#xefa2;</i>
        </a>
        
      </div>
  
      <a class="text-link" href="https://github.com/TomasMikula/libretto">GitHub</a>
      
      <span class="row"></span>
      
    </header>

    <nav id="sidebar">

      <ul class="nav-list">
        <li class="level1 active"><a href="#">Libretto Basics</a></li>
      </ul>
      
    </nav>

    <div id="container">

      <nav id="page-nav">
        <p class="header"><a href="#">Libretto Basics</a></p>
        
        <ul class="nav-list">
          <li class="level1"><a href="#setup">Setup</a></li>
          <li class="level2"><a href="#sbt-project-setup">sbt project setup</a></li>
          <li class="level2"><a href="#imports">Imports</a></li>
          <li class="level1"><a href="#building-blocks">Building blocks</a></li>
          <li class="level1"><a href="#maximum-concurrency">Maximum concurrency</a></li>
          <li class="level1"><a href="#sequential-composition">Sequential composition</a></li>
          <li class="level1"><a href="#parallel-composition">Parallel composition</a></li>
          <li class="level1"><a href="#scala-notation">Scala notation</a></li>
          <li class="level1"><a href="#identity">Identity</a></li>
          <li class="level1"><a href="#associativity-of">Associativity of ⊗</a></li>
          <li class="level1"><a href="#symmetry-of">Symmetry of ⊗</a></li>
          <li class="level1"><a href="#the-no-flow-port-one">The no-flow port, <code>One</code></a></li>
          <li class="level1"><a href="#signals">Signals</a></li>
          <li class="level2"><a href="#immediate-signals">Immediate signals</a></li>
          <li class="level2"><a href="#non-dismissible-signals">Non-dismissible signals</a></li>
          <li class="level2"><a href="#dismissible-signals">Dismissible signals</a></li>
          <li class="level2"><a href="#forking-and-joining-signals">Forking and joining signals</a></li>
          <li class="level2"><a href="#inverting-signals">Inverting signals</a></li>
          <li class="level1"><a href="#either">Either (⊕)</a></li>
          <li class="level1"><a href="#choice">Choice (&amp;)</a></li>
          <li class="level1"><a href="#distributivity-of-over">Distributivity of ⊗ over ⊕</a></li>
          <li class="level1"><a href="#co-distributivity-of-over">Co-distributivity of ⊗ over &amp;</a></li>
          <li class="level1"><a href="#linearity-and-point-free-style">Linearity and point-free style</a></li>
          <li class="level1"><a href="#λ-syntax">λ-Syntax</a></li>
          <li class="level2"><a href="#how-it-works">How it works</a></li>
          <li class="level2"><a href="#operations-on-expressions">Operations on $-expressions</a></li>
          <li class="level2"><a href="#linearity-checking">Linearity checking</a></li>
          <li class="level1"><a href="#recursion">Recursion</a></li>
          <li class="level2"><a href="#recursive-types">Recursive types</a></li>
          <li class="level2"><a href="#recursive-functions">Recursive functions</a></li>
          <li class="level1"><a href="#racing">Racing</a></li>
          <li class="level2"><a href="#racing-is-a-source-of-non-determinism">Racing is a source of non-determinism</a></li>
          <li class="level1"><a href="#using-scala-values-and-functions">Using Scala values and functions</a></li>
          <li class="level1"><a href="#inverse-types">Inverse Types</a></li>
          <li class="level2"><a href="#duality-of-and">Duality of ⊕ and &amp;</a></li>
          <li class="level2"><a href="#universal-inversions">Universal Inversions</a></li>
          <li class="level1"><a href="#function-objects-and-higher-order-functions">Function Objects and Higher-Order Functions</a></li>
          <li class="level2"><a href="#function-objects-via-inversions">Function Objects via Inversions</a></li>
          <li class="level2"><a href="#λ-expressions">Λ-expressions</a></li>
          <li class="level1"><a href="#equality-of-libretto-programs">Equality of Libretto programs</a></li>
        </ul>
        
        <p class="footer"></p>
      </nav>

      <main class="content">

        <h1 id="libretto-basics" class="title">Libretto Basics</h1>
        <p>A concurrent program in Libretto DSL is a <em>pure value</em> of a certain type (such as the type <code>Done -⚬ Done</code> or
        <code>Done -⚬ Val[String]</code>).
        Such a value is a mere <em>description,</em> or <em>blueprint,</em> of a program to be executed.
        The blueprint can then be passed to an interpreter for execution.</p>
        <p>Programmer&#39;s task is then to write Scala code that first assembles a blueprint and then
        passes is to an interpreter for execution. We thus think of run-time as split into
        <strong>assembly time</strong> and <strong>execution time</strong>.</p>
        
        <h2 id="setup" class="section"><a class="anchor-link left" href="#setup"><i class="icofont-laika">&#xef71;</i></a>Setup</h2>
        
        <h3 id="sbt-project-setup" class="section"><a class="anchor-link left" href="#sbt-project-setup"><i class="icofont-laika">&#xef71;</i></a>sbt project setup</h3>
        <p>You will need Scala 3 in order to use Libretto. Scala 3 requires a fairly recent version of sbt. Specify the sbt version in your <code>project/build.properties</code> file:</p>
        <pre class="keep-together pdf epub"><code class="properties">sbt.version=1.6.2</code></pre>
        <p>In your <code>build.sbt</code>, set the Scala version to Scala 3 and add the dependency on Libretto:</p>
        <pre class="keep-together pdf epub"><code class="sbt">scalaVersion := &quot;3.1.2&quot;

libraryDependencies += &quot;dev.continuously&quot; %% &quot;libretto&quot; % &quot;0.2-M3&quot;</code></pre>
        <p>Check <a href="https://search.maven.org/search?q=dev.continuously%20libretto">search.maven.org</a> for the latest version of
        Libretto.</p>
        
        <h3 id="imports" class="section"><a class="anchor-link left" href="#imports"><i class="icofont-laika">&#xef71;</i></a>Imports</h3>
        <p>The code snippets below use these imports:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">libretto</span><span>.</span><span class="type-name">StarterKit</span><span>.</span><span class="identifier">dsl</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">libretto</span><span>.</span><span class="type-name">StarterKit</span><span>.</span><span class="identifier">dsl</span><span>.</span><span class="identifier">$</span><span>.</span><span class="identifier">_</span></code></pre>
        
        <h2 id="building-blocks" class="section"><a class="anchor-link left" href="#building-blocks"><i class="icofont-laika">&#xef71;</i></a>Building blocks</h2>
        <p>Libretto programs are composed of <strong>components</strong> with typed <strong>in-ports</strong> and <strong>out-ports</strong>,
        such as this one:</p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│          ╎C│
┟─┘          ┟─┘
┞─┐          ┞─┐
╎B│          ╎D│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>We draw in-ports on the left and out-ports on the right.</p>
        <p>The in-ports and out-ports define the <em>interface</em> of a component.</p>
        <p>We can think of a component as a part of a system that runs autonomously and communicates with the rest of the system
        through its in-ports and out-ports.</p>
        <p>☝️ Do <em>not</em> assume that through in-ports information flows into the component and through out-ports information flows out
        of the component. That may or may not be the case. In general, information may flow in either direction or even in both
        directions through an in-port as well as through an out-port. However, the distinction between in-ports and out-ports
        is important for composition, see below.</p>
        
        <h2 id="maximum-concurrency" class="section"><a class="anchor-link left" href="#maximum-concurrency"><i class="icofont-laika">&#xef71;</i></a>Maximum concurrency</h2>
        <p>We can be sure that event <em>e<sub>2</sub></em> happens after event <em>e<sub>1</sub></em> only if <em>e<sub>2</sub></em>
        <strong>causally depends</strong> on <em>e<sub>1</sub></em>. If there is no causal dependence between <em>e<sub>1</sub></em> and <em>e<sub>2</sub></em>,
        then they happen concurrently (☝️ but not necessarily in parallel).</p>
        <p>This is different from what most people are used to. It usually takes some work to make things happen concurrently.
        In Libretto, it takes some work to make things happen sequentially if there is no natural causal dependence between
        them.</p>
        <p>As we proceed, we will get an idea of what does and what does not introduce a causal dependence.</p>
        
        <h2 id="sequential-composition" class="section"><a class="anchor-link left" href="#sequential-composition"><i class="icofont-laika">&#xef71;</i></a>Sequential composition</h2>
        <p>We can connect an out-port to an in-port (but not to another out-port) of the same type on another component.
        For example, these two components <code>f</code> and <code>g</code></p>
        <pre><code>┏━━━━━━━━━━━━┓    ┏━━━━━━━━━━━━┓
┞─┐          ┞─┐  ┞─┐          ┞─┐
╎A│    f     ╎B│  ╎B│    g     ╎C│
┟─┘          ┟─┘  ┟─┘          ┟─┘
┗━━━━━━━━━━━━┛    ┗━━━━━━━━━━━━┛</code></pre>
        <p>can be composed into a composite component <code>g ⚬ f</code></p>
        <pre><code>┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┞─┐                            ┞─┐
╎A│           g ⚬ f            ╎C│
┟─┘                            ┟─┘
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛</code></pre>
        <p>☝️ Although we call it <em>sequential</em> composition, do <em>not</em> assume that<code>g</code> takes place &quot;after&quot; <code>f</code>, in a temporal or
        causal sense. There may or may not be causal dependence in either direction, or even both directions simultaneously.
        We would need know the interface type <code>B</code> and possibly the inner
        workings of the components to make judgments about causal dependence. In general, processing can take place in <code>g</code> even
        before any information passes through the <code>B</code> interface.</p>
        
        <h2 id="parallel-composition" class="section"><a class="anchor-link left" href="#parallel-composition"><i class="icofont-laika">&#xef71;</i></a>Parallel composition</h2>
        <p>Any two components <code>f</code>, <code>g</code></p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│    f     ╎C│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛
┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎B│    g     ╎D│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>can be put alongside each other (parallel to each other) to form their <em>parallel composition</em> <em>f ⊗ g</em></p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│          ╎C│
┟─┘  f ⊗ g   ┟─┘
┞─┐          ┞─┐
╎B│          ╎D│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        
        <h2 id="scala-notation" class="section"><a class="anchor-link left" href="#scala-notation"><i class="icofont-laika">&#xef71;</i></a>Scala notation</h2>
        <p>The graphical notation is useful for a human, but eventually we have to express our Libretto program by means of the
        host language, Scala.</p>
        <p>A component <code>f</code> with one in-port of type <code>A</code> and one out-port of type <code>B</code></p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│    f     ╎B│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>is a value <code>f</code> of type <code>A -⚬ B</code>.</p>
        <p>The funny arrow-like symbol, <code>-⚬</code>, also called a <em>lollipop</em>, is borrowed from linear logic where it denotes <em>linear
        implication</em> and in Libretto we similarly call it a <em>linear function.</em> We will also call it simply an <em>arrow</em> if there
        is no risk of confusion with other things called arrows. So we use the terms component, linear function and arrow as
        synonyms.</p>
        <p>☝️ Although we call <code>-⚬</code> a linear <em>function,</em> some intuitions one might have about Scala functions (<code>=&gt;</code>) do not
        transfer to <code>-⚬</code>. With a Scala function, there is nothing going on inside it until we pass all the inputs to it.
        Once we get the output (and we get the whole output all at once), the Scala function is done. Remember, however,
        that Libretto&#39;s linear function is a component, a part of the system that runs on its own and perhaps communicates
        with its environment through the ports.
        However, composition of Libretto&#39;s linear functions works just like composition of Scala functions.</p>
        <p>In Scala, we model multiple in-ports as a single in-port of a composite type, and similarly for out-ports.
        As an example, a component <code>f</code> with two in-ports of types <code>A</code> and <code>B</code> and two out-ports of types <code>C</code> and <code>D</code></p>
        <pre><code>┏━━━━━━━━━━━━┓
┞─┐          ┞─┐
╎A│          ╎C│
┟─┘    f     ┟─┘
┞─┐          ┞─┐
╎B│          ╎D│
┟─┘          ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>is represented as a value <code>f: (A ⊗ B) -⚬ (C ⊗ D)</code>.
        The expression <em>X ⊗ Y</em> represents a <strong>concurrent pair</strong> of <em>X</em> and <em>Y</em>, sometimes referred to simply as <em>X times Y</em>.
        It is also called a <em>tensor product</em> or a <em>monoidal product</em> (of a monoidal category).</p>
        <p>Because the ⊗ symbol is usually not very intelligible in monospace fonts (e.g. hardly distinguishable from ⊕, compare
        <code>⊗</code> vs. <code>⊕</code>), in code we usually use <code>|*|</code> for the concurrent pair.
        The above component is then <code>f: (A |*| B) -⚬ (C |*| D)</code>.</p>
        <p>The operator for sequential composition introduced above is <code>andThen</code> (again, do not assume any temporal meaning):</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">andThen</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>, </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">C</span><span>): </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span></code></pre>
        <p>There are syntactic extensions that let us write</p>
        <ul>
          <li><code>f &gt; g</code> instead of <code>andThen(f, g)</code>,</li>
          <li><code>f ⚬ g</code> (read <em>f after g</em>) instead of <code>andThen(g, f)</code>.</li>
        </ul>
        <p>The operator for parallel composition is <code>par</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">par</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>, </span><span class="type-name">D</span><span>](
  </span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>,
  </span><span class="identifier">g</span><span>: </span><span class="type-name">C</span><span> -⚬ </span><span class="type-name">D</span><span>,
): (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) -⚬ (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">D</span><span>)</span></code></pre>
        
        <h2 id="identity" class="section"><a class="anchor-link left" href="#identity"><i class="icofont-laika">&#xef71;</i></a>Identity</h2>
        <p>For any type <code>A</code> there is an <em>identity</em> function (component)</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━┓
 *  ┞─┐          ┞─┐
 *  ╎A│  id[A]   ╎A│
 *  ┟─┘          ┟─┘
 *  ┗━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">id</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">A</span></code></pre>
        <p>All it does is relay information from in-ports to out-ports and from out-ports to in-ports, unchanged.
        It can be thought of as an extension cord. It is not useful by itself, but it comes in handy in compositions.</p>
        <p>As an example, say that we want to connect the second out-port of <code>f: A -⚬ (B |*| C)</code> to the in-port of
        <code>g: C -⚬ D</code>. In the graphical notation, it is tempting to just put them next to each other like this:</p>
        <pre><code>┏━━━━━━━━━━━┓
┃           ┞─┐
┃           ╎B│
┞─┐         ┟─┘
╎A│   f     ┣━━━━━━━━━━━┓
┟─┘         ┞─┐         ┞─┐
┃           ╎C│    g    ╎D│
┃           ┟─┘         ┟─┘
┗━━━━━━━━━━━┻━━━━━━━━━━━┛</code></pre>
        <p>But how would we do it in Scala using only what we already know, namely sequential and parallel composition?
        We can first place <code>id[B]</code> parallel to <code>g</code>, obtaining</p>
        <pre><code>                    ┏━━━━━━━━━━━┓
                    ┞─┐         ┞─┐
                    ╎B│  id[B]  ╎B│
                    ┟─┘         ┟─┘
par(id[B], g)   =   ┠╌╌╌╌╌╌╌╌╌╌╌┨
                    ┞─┐         ┞─┐
                    ╎C│    g    ╎D│
                    ┟─┘         ┟─┘
                    ┗━━━━━━━━━━━┛</code></pre>
        <p>and then place it after <code>f</code>, obtaining</p>
        <pre><code>                        ┏━━━━━━━━━━━┯━━━━━━━━━━━┓
                        ┃           ├─┐         ┞─┐
                        ┃           ╎B│  id[B]  ╎B│
                        ┞─┐         ├─┘         ┟─┘
f &gt; par(id[B], g)   =   ╎A│   f     ├╌╌╌╌╌╌╌╌╌╌╌┨
                        ┟─┘         ├─┐         ┞─┐
                        ┃           ╎C│    g    ╎D│
                        ┃           ├─┘         ┟─┘
                        ┗━━━━━━━━━━━┷━━━━━━━━━━━┛</code></pre>
        <p>There are shortcuts for transforming just one part of a concrrent pair, like above,
        using identity in the other part:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/** Applies `f` to the first part of a concurrent pair. */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">fst</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span><span>): (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) -⚬ (</span><span class="type-name">C</span><span> |*| </span><span class="type-name">B</span><span>) =
  </span><span class="identifier">par</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">id</span><span>[</span><span class="type-name">B</span><span>])

</span><span class="comment">/** Applies `g` to the second part of a concurrent pair. */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">snd</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">C</span><span>): (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) -⚬ (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) =
  </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">g</span><span>)</span></code></pre>
        
        <h2 id="associativity-of" class="section"><a class="anchor-link left" href="#associativity-of"><i class="icofont-laika">&#xef71;</i></a>Associativity of ⊗</h2>
        <p>If we are designing a component with more than two in-ports or out-ports, such as this one,</p>
        <pre><code>┏━━━━━━━━━━━━┓
┃            ┞─┐
┃            ╎B│
┃            ┟─┘
┞─┐          ┞─┐
╎A│    f     ╎C│
┟─┘          ┟─┘
┃            ┞─┐
┃            ╎D│
┃            ┟─┘
┗━━━━━━━━━━━━┛</code></pre>
        <p>we need to choose how to group the ports using ⊗ (<code>|*|</code>) in the Scala representation.
        For the above component, there are two possibilities:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">f1</span><span>: </span><span class="type-name">A</span><span> -⚬ ((</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>) |*| </span><span class="type-name">D</span><span>)
</span><span class="identifier">f2</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> |*| (</span><span class="type-name">C</span><span> |*| </span><span class="type-name">D</span><span>))</span></code></pre>
        <p>Sometimes one way is more natural than the other, but often it is an arbitrary choice.
        We need not worry about it too much, though, because the grouping does not matter:
        we can always regroup the ports using</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">assocLR</span><span>[</span><span class="type-name">X</span><span>, </span><span class="type-name">Y</span><span>, </span><span class="type-name">Z</span><span>]: ((</span><span class="type-name">X</span><span> |*| </span><span class="type-name">Y</span><span>) |*| </span><span class="type-name">Z</span><span>) -⚬ (</span><span class="type-name">X</span><span> |*| (</span><span class="type-name">Y</span><span> |*| </span><span class="type-name">Z</span><span>))
</span><span class="keyword">def</span><span> </span><span class="declaration-name">assocRL</span><span>[</span><span class="type-name">X</span><span>, </span><span class="type-name">Y</span><span>, </span><span class="type-name">Z</span><span>]: (</span><span class="type-name">X</span><span> |*| (</span><span class="type-name">Y</span><span> |*| </span><span class="type-name">Z</span><span>)) -⚬ ((</span><span class="type-name">X</span><span> |*| </span><span class="type-name">Y</span><span>) |*| </span><span class="type-name">Z</span><span>)</span></code></pre>
        <pre><code>┏━━━━━━━━━━━━━━━━┓             ┏━━━━━━━━━━━━━━━━┓
┞─┐              ┞─┐           ┞─┐              ┞─┐
╎X│              ╎X│           ╎X│              ╎X│
╎⊗│              ┟─┘           ┟─┘              ╎⊗│
╎Y│   assocLR    ┞─┐           ┞─┐   assocRL    ╎Y│
┟─┘              ╎Y│           ╎Y│              ┟─┘
┞─┐              ╎⊗│           ╎⊗│              ┞─┐
╎Z│              ╎Z│           ╎Z│              ╎Z│
┟─┘              ┟─┘           ┟─┘              ┟─┘
┗━━━━━━━━━━━━━━━━┛             ┗━━━━━━━━━━━━━━━━┛</code></pre>
        <p>Thus, if we have</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">f1</span><span>: </span><span class="type-name">A</span><span> -⚬ ((</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>) |*| </span><span class="type-name">D</span><span>) =
  ???</span></code></pre>
        <p>we can always get</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">f2</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> |*| (</span><span class="type-name">C</span><span> |*| </span><span class="type-name">D</span><span>)) =
  </span><span class="identifier">f1</span><span> &gt; </span><span class="identifier">assocLR</span></code></pre>
        
        <h2 id="symmetry-of" class="section"><a class="anchor-link left" href="#symmetry-of"><i class="icofont-laika">&#xef71;</i></a>Symmetry of ⊗</h2>
        <p>The relative order of ports does not matter, either.</p>
        <p>If, for example, we have a component</p>
        <pre><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━━━━━┓
 *  ┞─┐              ┞─┐
 *  ╎A│              ╎C│
 *  ┟─┘              ┟─┘
 *  ┃       g1       ┞─┐
 *  ┃                ╎D│
 *  ┞─┐              ╎⊗│
 *  ╎B│              ╎E│
 *  ┟─┘              ┟─┘
 *  ┗━━━━━━━━━━━━━━━━┛
 *
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">g1</span><span>: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) -⚬ (</span><span class="type-name">C</span><span> |*| (</span><span class="type-name">D</span><span> |*| </span><span class="type-name">E</span><span>)) =
  ???</span></code></pre>
        <p>and need</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">g2</span><span>: (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">A</span><span>) -⚬ ((</span><span class="type-name">E</span><span> |*| </span><span class="type-name">D</span><span>) |*| </span><span class="type-name">C</span><span>) =
  ???</span></code></pre>
        <p>we can &quot;easily&quot; get it using <code>swap</code></p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━━━━━┓
 *  ┞─┐              ┞─┐
 *  ╎X│              ╎Y│
 *  ┟─┘  swap[X,Y]   ┟─┘
 *  ┞─┐              ┞─┐
 *  ╎Y│              ╎X│
 *  ┟─┘              ┟─┘
 *  ┗━━━━━━━━━━━━━━━━┛
 *
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">swap</span><span>[</span><span class="type-name">X</span><span>, </span><span class="type-name">Y</span><span>]: (</span><span class="type-name">X</span><span> |*| </span><span class="type-name">Y</span><span>) -⚬ (</span><span class="type-name">Y</span><span> |*| </span><span class="type-name">X</span><span>)</span></code></pre>
        <p>like this</p>
        <pre><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┓
 *  ┞─┐          ├─┐              ├─┐              ├─┐             ┞─┐
 *  ╎B│          ╎A│              ╎C│              ╎D│             ╎E│
 *  ┟─┘          ├─┘              ├─┘              ╎⊗│  swap[D, E] ╎⊗│
 *  ┃            ╎                ╎ swap[C, D ⊗ E] ╎E│             ╎D│
 *  ┃ swap[B, A] ╎       g1       ├─┐              ├─┘             ┟─┘
 *  ┃            ╎                ╎D│              ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┨
 *  ┞─┐          ├─┐              ╎⊗│              ├─┐             ┞─┐
 *  ╎A│          ╎B│              ╎E│              ╎C│    id[C]    ╎C│
 *  ┟─┘          ├─┘              ├─┘              ├─┘             ┟─┘
 *  ┗━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">g2</span><span>: (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">A</span><span>) -⚬ ((</span><span class="type-name">E</span><span> |*| </span><span class="type-name">D</span><span>) |*| </span><span class="type-name">C</span><span>) =
  </span><span class="identifier">swap</span><span>[</span><span class="type-name">B</span><span>, </span><span class="type-name">A</span><span>] &gt; </span><span class="identifier">g1</span><span> &gt; </span><span class="identifier">swap</span><span>[</span><span class="type-name">C</span><span>, </span><span class="type-name">D</span><span> |*| </span><span class="type-name">E</span><span>] &gt; </span><span class="identifier">par</span><span>(</span><span class="identifier">swap</span><span>[</span><span class="type-name">D</span><span>, </span><span class="type-name">E</span><span>], </span><span class="identifier">id</span><span>[</span><span class="type-name">C</span><span>])</span></code></pre>
        <p>Okay, that was a lot of glue code to wrap around the function <code>g1</code>.
        Having to explicitly put in the glue code can be quite distracting from what is going on.
        Let&#39;s just foreshadow here that alternatively, we can use λ-syntax,
        which generates the glue code automatically:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">g2</span><span>: (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">A</span><span>) -⚬ ((</span><span class="type-name">E</span><span> |*| </span><span class="type-name">D</span><span>) |*| </span><span class="type-name">C</span><span>) =
  λ { </span><span class="keyword">case</span><span> (</span><span class="identifier">b</span><span> |*| </span><span class="identifier">a</span><span>) =&gt;
    </span><span class="keyword">val</span><span> (</span><span class="identifier">c</span><span> |*| (</span><span class="identifier">d</span><span> |*| </span><span class="identifier">e</span><span>)) = </span><span class="identifier">g1</span><span>(</span><span class="identifier">a</span><span> |*| </span><span class="identifier">b</span><span>)
    (</span><span class="identifier">e</span><span> |*| </span><span class="identifier">d</span><span>) |*| </span><span class="identifier">c</span><span>
  }</span></code></pre>
        <p>More on λ-syntax later.</p>
        
        <h2 id="the-no-flow-port-one" class="section"><a class="anchor-link left" href="#the-no-flow-port-one"><i class="icofont-laika">&#xef71;</i></a>The no-flow port, <code>One</code></h2>
        <p>Sometimes we want a component with no in-ports or no out-ports, such as these ones</p>
        <pre><code>┏━━━━━━━━━━━━┓            ┏━━━━━━━━━━━━┓
┃            ┞─┐          ┞─┐          ┃
┃      f     ╎A│          ╎B│    g     ┃
┃            ┟─┘          ┟─┘          ┃
┗━━━━━━━━━━━━┛            ┗━━━━━━━━━━━━┛</code></pre>
        <p>In Scala representation, however, we have to specify the type of in-port and the type of outport.
        There is a special fake port type, <code>One</code>, through which there is no flow of information in either direction.</p>
        <p>We can declare the above two components as</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">f</span><span>: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">A</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">One</span></code></pre>
        <p>In graphical notation, we omit <code>One</code>-typed ports if they do not add any value (such as above), but keep them if they do
        (such as below).</p>
        <p>We can freely add and remove <code>One</code> to/from in-ports and/or out-ports using the following primitives:</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━┓           ┏━━━━━━━━━━━━━━━━┓
//  ┃             ┞───┐       ┞───┐            ┃
//  ┃             ╎One│       ╎One│            ┃
//  ┃ introFst[A] ┟───┘       ┟───┘ elimFst[A] ┃
//  ┞───┐         ┞───┐       ┞───┐            ┞───┐
//  ╎ A │         ╎ A │       ╎ A │            ╎ A │
//  ┟───┘         ┟───┘       ┟───┘            ┟───┘
//  ┗━━━━━━━━━━━━━┛           ┗━━━━━━━━━━━━━━━━┛
//
//  ┏━━━━━━━━━━━━━┓           ┏━━━━━━━━━━━━━━━━┓
//  ┞───┐         ┞───┐       ┞───┐            ┞───┐
//  ╎ A │         ╎ A │       ╎ A │            ╎ A │
//  ┟───┘         ┟───┘       ┟───┘            ┟───┘
//  ┃ introSnd[A] ┞───┐       ┞───┐ elimSnd[A] ┃
//  ┃             ╎One│       ╎One│            ┃
//  ┃             ┟───┘       ┟───┘            ┃
//  ┗━━━━━━━━━━━━━┛           ┗━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">introFst</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">One</span><span> |*| </span><span class="type-name">A</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">introSnd</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">One</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">elimFst</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">One</span><span> |*| </span><span class="type-name">A</span><span>) -⚬ </span><span class="type-name">A</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">elimSnd</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">One</span><span>) -⚬ </span><span class="type-name">A</span></code></pre>
        <p>Soon we are going to see useful cases of adding and removing <code>One</code>s.</p>
        <p>Since there is no flow of information through <code>One</code>, there is also <em>no causal dependency through <code>One</code>-typed ports.</em>
        This means, for example, that in</p>
        <pre><code>┏━━━━━━━━━┯━━━━━━━━━━━━━┯━━━━━━━━━━━┓
┃         ╎             ├───┐       ┞───┐
┃         ╎             ╎One│   g   ╎ B │
┃         ╎             ├───┘       ┟───┘
┃    f    ╎ introFst[C] ├╌╌╌╌╌╌╌╌╌╌╌┨
┞───┐     ├───┐         ├───┐       ┞───┐
╎ A │     ╎ C │         ╎ C │ id[C] ╎ C │
┟───┘     ├───┘         ├───┘       ┟───┘
┗━━━━━━━━━┷━━━━━━━━━━━━━┷━━━━━━━━━━━┛</code></pre>
        <p>there is no causal dependence of <code>g</code> on anything in <code>f</code> going through the <code>introFst[C]</code> component.</p>
        
        <h2 id="signals" class="section"><a class="anchor-link left" href="#signals"><i class="icofont-laika">&#xef71;</i></a>Signals</h2>
        <p>By a signal we mean a notification that some event has occurred. The signal itself carries no information about the
        event, though, it only signals that the event has occurred.</p>
        <p>There are 4 types of signals, differing in the direction of travel and/or whether they can be dismissed:</p>
        <table>
          <thead>
            <tr>
              <th></th>
              <th>Non-dismissible</th>
              <th>Dismissible</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Positive (left-to-right)</td>
              <td><code>Done</code></td>
              <td><code>Ping</code></td>
            </tr>
            <tr>
              <td>Negative (right-to-left)</td>
              <td><code>Need</code></td>
              <td><code>Pong</code></td>
            </tr>
          </tbody>
        </table>
        <ul>
          <li>Positive signals (<code>Done</code>, <code>Ping</code>) travel in the direction of <code>-⚬</code>.</li>
          <li>Negative signals (<code>Need</code>, <code>Pong</code>) travel in the direction opposite to <code>-⚬</code>.</li>
        </ul>
        <p>Signals are useful for creating causal dependencies: one component might wait for a signal from another component
        before proceeding with further processing. For example, the signal might signal completion of a request and further
        processing might be accepting another request, effectively sequencing request processing.</p>
        <p>For someone used to <code>Future</code> and <code>Promise</code>, it might be helpful, <em>despite important differences,</em> to initially view</p>
        <ul>
          <li><code>Done</code> and <code>Ping</code> as <code>Future[Unit]</code>,</li>
          <li><code>Need</code> and <code>Pong</code> as <code>Promise[Unit]</code>.</li>
        </ul>
        
        <h3 id="immediate-signals" class="section"><a class="anchor-link left" href="#immediate-signals"><i class="icofont-laika">&#xef71;</i></a>Immediate signals</h3>
        <p>There are primitive components that fire a signal immediately. More precisely, as soon as it is certain that
        they will be executed (but we haven&#39;t seen any conditional operators yet). These are</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━┓         ┏━━━━━━━━━━━━━━┓     ┏━━━━━━━━━━━━┓         ┏━━━━━━━━━━━━━━┓
//  ┃            ┞────┐    ┞────┐         ┃     ┃            ┞────┐    ┞────┐         ┃
//  ┃    done    ╎Done│    ╎Need│  need   ┃     ┃    ping    ╎Ping│    ╎Pong│  pong   ┃
//  ┃            ┟────┘    ┟────┘         ┃     ┃            ┟────┘    ┟────┘         ┃
//  ┗━━━━━━━━━━━━┛         ┗━━━━━━━━━━━━━━┛     ┗━━━━━━━━━━━━┛         ┗━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">done</span><span>: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">Done</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">need</span><span>: </span><span class="type-name">Need</span><span> -⚬ </span><span class="type-name">One</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">ping</span><span>: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">Ping</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">pong</span><span>: </span><span class="type-name">Pong</span><span> -⚬ </span><span class="type-name">One</span></code></pre>
        
        <h3 id="non-dismissible-signals" class="section"><a class="anchor-link left" href="#non-dismissible-signals"><i class="icofont-laika">&#xef71;</i></a>Non-dismissible signals</h3>
        <p><code>Done</code> and <code>Need</code> are non-dismissible: once created, they have to be used
        (typically as a trigger for another action).
        In this way, an incoming non-dismissible signal, whether <code>Done</code> incoming from the left
        or <code>Need</code> incoming from the right, is a liability.</p>
        <p><code>Done</code> and <code>Need</code> are used to transfer the obligation to wait for a running task.
        Ignoring such a signal would mean losing track of the running task, which is a resource leak,
        and thus is prohibited.</p>
        
        <h3 id="dismissible-signals" class="section"><a class="anchor-link left" href="#dismissible-signals"><i class="icofont-laika">&#xef71;</i></a>Dismissible signals</h3>
        <p><code>Ping</code> and <code>Pong</code> are used to signal completion of a task, but do not transfer the obligation
        to await that task, because someone else is already keeping track of it.</p>
        <p>The receiver of <code>Ping</code> or <code>Pong</code> may ignore the signal using</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">dismissPing</span><span>: </span><span class="type-name">Ping</span><span> -⚬ </span><span class="type-name">One</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">dismissPong</span><span>: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">Pong</span></code></pre>
        
        <h3 id="forking-and-joining-signals" class="section"><a class="anchor-link left" href="#forking-and-joining-signals"><i class="icofont-laika">&#xef71;</i></a>Forking and joining signals</h3>
        <p><em>Forking</em> a signal means that as soon as the signal arrives, two new signals are fired.</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓
//  ┃   fork   ┞────┐    ┃ forkPing ┞────┐    ┞────┐     ┃         ┞────┐     ┃
//  ┃          ╎Done│    ┃          ╎Ping│    ╎Need│     ┃         ╎Pong│     ┃
//  ┞────┐     ┟────┘    ┞────┐     ┟────┘    ┟────┘     ┞────┐    ┟────┘     ┞────┐
//  ╎Done│     ┃         ╎Ping│     ┃         ┃ forkNeed ╎Need│    ┃ forkPong ╎Pong│
//  ┟────┘     ┞────┐    ┟────┘     ┞────┐    ┞────┐     ┟────┘    ┞────┐     ┟────┘
//  ┃          ╎Done│    ┃          ╎Ping│    ╎Need│     ┃         ╎Pong│     ┃
//  ┃          ┟────┘    ┃          ┟────┘    ┟────┘     ┃         ┟────┘     ┃
//  ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">fork</span><span>     : </span><span class="type-name">Done</span><span> -⚬ (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">Done</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">forkPing</span><span> : </span><span class="type-name">Ping</span><span> -⚬ (</span><span class="type-name">Ping</span><span> |*| </span><span class="type-name">Ping</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">forkNeed</span><span> : (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">Need</span><span>) -⚬ </span><span class="type-name">Need</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">forkPong</span><span> : (</span><span class="type-name">Pong</span><span> |*| </span><span class="type-name">Pong</span><span>) -⚬ </span><span class="type-name">Pong</span></code></pre>
        <p>Remember that <code>Need</code> and <code>Pong</code> travel from right to left, so <code>forkNeed</code> and <code>forkPong</code> have
        one signal coming in from the right and two signals coming out on the left.</p>
        <p><em>Joining</em> two signals means to fire a signal as soon as both signals arrive.</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓
//  ┞────┐     ┃         ┞────┐     ┃         ┃ joinNeed ┞────┐    ┃ joinPong ┞────┐
//  ╎Done│     ┃         ╎Ping│     ┃         ┃          ╎Need│    ┃          ╎Pong│
//  ┟────┘     ┞────┐    ┟────┘     ┞────┐    ┞────┐     ┟────┘    ┞────┐     ┟────┘
//  ┃   join   ╎Done│    ┃ joinPing ╎Ping│    ╎Need│     ┃         ╎Pong│     ┃
//  ┞────┐     ┟────┘    ┞────┐     ┟────┘    ┟────┘     ┞────┐    ┟────┘     ┞────┐
//  ╎Done│     ┃         ╎Ping│     ┃         ┃          ╎Need│    ┃          ╎Pong│
//  ┟────┘     ┃         ┟────┘     ┃         ┃          ┟────┘    ┃          ┟────┘
//  ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">join</span><span>     : (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">Done</span><span>) -⚬ </span><span class="type-name">Done</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">joinPing</span><span> : (</span><span class="type-name">Ping</span><span> |*| </span><span class="type-name">Ping</span><span>) -⚬ </span><span class="type-name">Ping</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">joinNeed</span><span> : </span><span class="type-name">Need</span><span> -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">Need</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">joinPong</span><span> : </span><span class="type-name">Pong</span><span> -⚬ (</span><span class="type-name">Pong</span><span> |*| </span><span class="type-name">Pong</span><span>)</span></code></pre>
        <p>Again, since <code>Need</code> and <code>Pong</code> travel from right to left, <code>joinNeed</code> and <code>joinPong</code> have
        two signals coming in from the right and one signal coming out on the left</p>
        
        <h3 id="inverting-signals" class="section"><a class="anchor-link left" href="#inverting-signals"><i class="icofont-laika">&#xef71;</i></a>Inverting signals</h3>
        <p>There are primitives to invert the direction of a signal.</p>
        <p>A signal traveling to the left (<code>Need</code>, <code>Pong</code>) can be changed to the respective signal traveling to the right (<code>Done</code>, <code>Ping</code>).</p>
        <p>A signal traveling to the right (<code>Done</code>, <code>Ping</code>) can be changed to the respective signal traveling to the left (<code>Need</code>, <code>Pong</code>).</p>
        <pre><code class="nohighlight"><span class="comment">//  lInvertSignal           rInvertSignal      lInvertPongPing        rInvertPingPong
//  ┏━━━━━━━━━━┓             ┏━━━━━━━━━━┓      ┏━━━━━━━━━━┓             ┏━━━━━━━━━━┓
//  ┃          ┃             ┃          ┃      ┃          ┃             ┃          ┃
//  ┃          ┞────┐        ┞────┐     ┃      ┃          ┞────┐        ┞────┐     ┃
//  ┃       ┌┄┄╎Need│←┄    ┄→╎Done│┄┄┐  ┃      ┃       ┌┄┄╎Pong│←┄    ┄→╎Ping│┄┄┐  ┃
//  ┃       ┆  ┟────┘        ┟────┘  ┆  ┃      ┃       ┆  ┟────┘        ┟────┘  ┆  ┃
//  ┃       ┆  ┃             ┃       ┆  ┃      ┃       ┆  ┃             ┃       ┆  ┃
//  ┃       ┆  ┞────┐        ┞────┐  ┆  ┃      ┃       ┆  ┞────┐        ┞────┐  ┆  ┃
//  ┃       └┄→╎Done│┄→    ←┄╎Need│←┄┘  ┃      ┃       └┄→╎Ping│┄→    ←┄╎Pong│←┄┘  ┃
//  ┃          ┟────┘        ┟────┘     ┃      ┃          ┟────┘        ┟────┘     ┃
//  ┗━━━━━━━━━━┛             ┗━━━━━━━━━━┛      ┗━━━━━━━━━━┛             ┗━━━━━━━━━━┛
</span><span>

</span><span class="keyword">def</span><span> </span><span class="declaration-name">lInvertSignal</span><span>   : </span><span class="type-name">One</span><span> -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">Done</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">rInvertSignal</span><span>   : (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">Need</span><span>) -⚬ </span><span class="type-name">One</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">rInvertPingPong</span><span> : (</span><span class="type-name">Ping</span><span> |*| </span><span class="type-name">Pong</span><span>) -⚬ </span><span class="type-name">One</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">lInvertPongPing</span><span> : </span><span class="type-name">One</span><span> -⚬ (</span><span class="type-name">Pong</span><span> |*| </span><span class="type-name">Ping</span><span>)</span></code></pre>
        <p>Using these, we can always move a signal to the other side of the <code>-⚬</code> arrow while changing its direction.
        For example, given</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━┓
 *  ┞────┐       ┃
 *  ╎Done│       ┃
 *  ┟────┘   f   ┃
 *  ┞────┐       ┞────┐
 *  ╎ A  │       ╎ B  │
 *  ┟────┘       ┟────┘
 *  ┗━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">f</span><span>: (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">A</span><span>) -⚬ </span><span class="type-name">B</span><span> =
  ???</span></code></pre>
        <p>we can always obtain</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━━┓
 *  ┃             ┞────┐
 *  ┃             ╎Need│
 *  ┃       g     ┟────┘
 *  ┞────┐        ┞────┐
 *  ╎ A  │        ╎ B  │
 *  ┟────┘        ┟────┘
 *  ┗━━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">g</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">B</span><span>) =
  ???</span></code></pre>
        <p>roughly like this</p>
        <pre><code>┏━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┓
┃ lInvertSignal ├────┐ id[Need] ┞────┐
┃          ┌┄┄┄┄╎Need│←┄┄┄┄┄┄┄┄┄╎Need│←┄
┃          ┆    ├────┘          ┟────┘
┃          ┆    ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┨
┃          ┆    ├────┐          ┃
┃          └┄┄┄→╎Done│          ┃
┃               ├────┘          ┃
┠╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤       f       ┃
┞───┐           ├───┐           ┞───┐
╎ A │   id[A]   ╎ A │           ╎ B │
┟───┘           ├───┘           ┟───┘
┗━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┛</code></pre>
        <p>and precisely (including all the necessary glue) like this</p>
        <pre><code class="nohighlight"><span class="comment">/*  ┏━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━┓
 *  ┃             ╎ lInvertSignal ├────┐         ├────┐          ┞────┐
 *  ┃ introFst[A] ├───┐           ╎Need│         ╎Need│ id[Need] ╎Need│
 *  ┃             ╎One│           ╎ ⊗  │         ├────┘          ┟────┘
 *  ┃             ├───┘           ╎Done│         ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┨
 *  ┃             ╎               ├────┘         ├────┐          ┃
 *  ┃             ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤    assocLR   ╎Done│          ┃
 *  ┞───┐         ├───┐           ├───┐          ╎ ⊗  │    f     ┞───┐
 *  ╎ A │         ╎ A │   id[A]   ╎ A │          ╎ A  │          ╎ B │
 *  ┟───┘         ├───┘           ├───┘          ├────┘          ┟───┘
 *  ┗━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━┛
 */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">g</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">B</span><span>) =
  </span><span class="identifier">introFst</span><span>[</span><span class="type-name">A</span><span>] &gt; </span><span class="identifier">par</span><span>(</span><span class="identifier">lInvertSignal</span><span>, </span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span>]) &gt; </span><span class="identifier">assocLR</span><span> &gt; </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>[</span><span class="type-name">Need</span><span>], </span><span class="identifier">f</span><span>)</span></code></pre>
        <p>We can also use λ-syntax:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">g</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">B</span><span>) =
  λ { </span><span class="identifier">a</span><span> =&gt;
    </span><span class="keyword">val</span><span> (</span><span class="identifier">a1</span><span> |*| (</span><span class="identifier">need</span><span> |*| </span><span class="identifier">done</span><span>)) =
      </span><span class="identifier">a</span><span> </span><span class="identifier">also</span><span> </span><span class="identifier">lInvertSignal</span><span>
    </span><span class="identifier">need</span><span> |*| </span><span class="identifier">f</span><span>(</span><span class="identifier">done</span><span> |*| </span><span class="identifier">a1</span><span>)
  }</span></code></pre>
        
        <h2 id="either" class="section"><a class="anchor-link left" href="#either"><i class="icofont-laika">&#xef71;</i></a>Either (⊕)</h2>
        <p>Type <code>A ⊕ B</code> (in code we use <code>A |+| B</code> for easier typing and better intelligibility) means either <code>A</code> or <code>B</code> (but
        not both), and which one it is going to be is decided by the component on the left.
        In other words, a component that has <code>A ⊕ B</code> as an out-port decides whether the interaction will continue as <code>A</code> or
        as <code>B</code>, while a component that has <code>A ⊕ B</code> as an in-port has to be able to handle either case.
        That is, the decision flows from left to right (the positive direction).</p>
        <p>Primitives for making the decision (introducing <code>|+|</code>) are</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━┓               ┏━━━━━━━━━━━━━━┓
//  ┞───┐          ┞───┐           ┃              ┞───┐
//  ╎ A │          ╎ A │           ┃ injectR[A,B] ╎ A │
//  ┟───┘          ╎ ⊕ │           ┞───┐          ╎ ⊕ │
//  ┃ injectL[A,B] ╎ B │           ╎ B │          ╎ B │
//  ┃              ┟───┘           ┟───┘          ┟───┘
//  ┗━━━━━━━━━━━━━━┛               ┗━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">injectL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">injectR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">B</span><span> -⚬ (</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>)</span></code></pre>
        <p>These are analogous to Scala&#39;s <code>Left(a)</code> and <code>Right(b)</code> constructors of <code>Either[A, B]</code>.</p>
        <p>The primitive for handling the actually chosen side (eliminating <code>|+|</code>) is</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/**  ┏━━━━━━━━━━━━━━┓
  *  ┞───┬──────────┨
  *  ╎ A ╷    f     ┞───┐
  *  ╎ ⊕ ├──────────╎ C │
  *  ╎ B ╵    g     ┟───┘
  *  ┟───┴──────────┨
  *  ┗━━━━━━━━━━━━━━┛
  */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">either</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span><span>, </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">C</span><span>): (</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">C</span></code></pre>
        <p>It is analogous to Scala&#39;s <code>Either#fold(f: A =&gt; C, g: B =&gt; C): C</code>.</p>
        <p>Once it is decided which case it is going to be, the corresponding component, <code>f</code> or <code>g</code>, is executed:</p>
        <pre><code>  ┏━━━━━━━━━━━━━━┓                          ┏━━━━━━━━━━━━━━┓
  ┞───┬────────╮ ┃                          ┞───┐          ┃
  ╎*A*╎   f    ╰─╀───┐                      ╎ A │     ╭────╀───┐
  ╎ ⊕ ├─────╮    ╎ C │                      ╎ ⊕ ├─────╯    ╎ C │
  ╎ B │     ╰────╁───┘                      ╎*B*╎   g    ╭─╁───┘
  ┟───┘          ┃                          ┟───┴────────╯ ┃
  ┗━━━━━━━━━━━━━━┛                          ┗━━━━━━━━━━━━━━┛</code></pre>
        <p>☝️ Note, however, that in <code>either(f &gt; h, g &gt; h)</code>, the common part, <code>h</code>, is certain to be executed in either case,
        and thus may start executing even before the <code>|+|</code> is decided. Indeed, it must hold that</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">either</span><span>(</span><span class="identifier">f</span><span> &gt; </span><span class="identifier">h</span><span>, </span><span class="identifier">g</span><span> &gt; </span><span class="identifier">h</span><span>) = </span><span class="identifier">either</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">g</span><span>) &gt; </span><span class="identifier">h</span></code></pre>
        
        <h2 id="choice" class="section"><a class="anchor-link left" href="#choice"><i class="icofont-laika">&#xef71;</i></a>Choice (&amp;)</h2>
        <p>Type <code>A &amp; B</code> (we use <code>A |&amp;| B</code> in code to avoid confusion with the bitwise and operator in Scala, and for consistency
        with <code>|*|</code> and <code>|+|</code>) means an <em>exclusive</em> choice between <code>A</code> and <code>B</code>.
        The component to the right of <code>A &amp; B</code>, i.e. the one that has <code>A &amp; B</code> as an in-port, gets to choose whether
        the interaction with the component to the left will continue as <code>A</code> or as <code>B</code>.
        The component to the left of <code>A &amp; B</code>, i.e. the one that has <code>A &amp; B</code> as an out-port, has to be able to provide
        either of them (but not both of them simultaneously).
        That is, the decision flows from right to left (the negative direction).</p>
        <p>Primitives for choosing one of the options (eliminating <code>|&amp;|</code>) are</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━━━━━┓               ┏━━━━━━━━━━━━━━━━━━┓
//  ┞───┐              ┞───┐           ┞───┐              ┃
//  ╎ A │              ╎ A │           ╎ A │              ┃
//  ╎ &amp; │ chooseL[A,B] ┟───┘           ╎ &amp; │ chooseR[A,B] ┞───┐
//  ╎ B │              ┃               ╎ B │              ╎ B │
//  ┟───┘              ┃               ┟───┘              ┟───┘
//  ┗━━━━━━━━━━━━━━━━━━┛               ┗━━━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">chooseL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: (</span><span class="type-name">A</span><span> |&amp;| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">A</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">chooseR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: (</span><span class="type-name">A</span><span> |&amp;| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">B</span></code></pre>
        <p>They are somewhat analogous to <code>_1</code>, <code>_2</code> methods on Scala&#39;s 2-tuple, except as if by using <code>_1</code> you give up the chance
        to ever access <code>_2</code>, and vice versa.</p>
        <p>The primitive for offering a choice (introducing <code>|&amp;|</code>) is</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/**  ┏━━━━━━━━━━━━━━┓
  *  ┃   ┌──────────╀───┐
  *  ┞───┤    f     ╷ B │
  *  ╎ A ├──────────┤ &amp; │
  *  ┟───┤    g     ╵ C │
  *  ┃   └──────────┟───┘
  *  ┗━━━━━━━━━━━━━━┛
  */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">choice</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>, </span><span class="identifier">g</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span><span>): </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> |&amp;| </span><span class="type-name">C</span><span>)</span></code></pre>
        <p>Once the choice is made from the right, the corresponding component, <code>f</code> or <code>g</code>, is executed:</p>
        <pre><code>  ┏━━━━━━━━━━━━━━┓                      ┏━━━━━━━━━━━━━━┓
  ┃     ╭────────╀───┐                  ┃              ┞───┐
  ┞───┬─╯   f    ╎*B*│                  ┞───┬─────╮    ╎ B │
  ╎ A ╎    ╭─────┤ &amp; │                  ╎ A ╎     ╰────┤ &amp; │
  ┟───┴────╯     │ C │                  ┟───┴─╮   g    │*C*│
  ┃              ┟───┘                  ┃     ╰────────╁───┘
  ┗━━━━━━━━━━━━━━┛                      ┗━━━━━━━━━━━━━━┛</code></pre>
        <p>☝️ Note, however, that in <code>choice(h &gt; f, h &gt; g)</code>, the common part, <code>h</code>, is certain to be executed in either case,
        and thus may start executing even before the <code>|&amp;|</code> is decided. Indeed, it must hold that</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">choice</span><span>(</span><span class="identifier">h</span><span> &gt; </span><span class="identifier">f</span><span>, </span><span class="identifier">h</span><span> &gt; </span><span class="identifier">g</span><span>) = </span><span class="identifier">h</span><span> &gt; </span><span class="identifier">choice</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">g</span><span>)</span></code></pre>
        
        <h2 id="distributivity-of-over" class="section"><a class="anchor-link left" href="#distributivity-of-over"><i class="icofont-laika">&#xef71;</i></a>Distributivity of ⊗ over ⊕</h2>
        <p>The tensor product ⊗ distributes over ⊕:</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━━━┓                        ┏━━━━━━━━━━━━━━━━┓
//  ┞─┐              ┞───┐                    ┞─┐              ┞───┐
//  ╎A│              ╎⎛A⎞│                    ╎A│              ╎⎛A⎞│
//  ┟─┘              ╎⎜⊗⎟│                    ╎⊕│              ╎⎜⊗⎟│
//  ┃                ╎⎝B⎠│                    ╎B│              ╎⎝C⎠│
//  ┞─┐ distributeL  ╎ ⊕ │                    ┟─┘ distributeR  ╎ ⊕ │
//  ╎B│              ╎⎛A⎞│                    ┃                ╎⎛B⎞│
//  ╎⊕│              ╎⎜⊗⎟│                    ┞─┐              ╎⎜⊗⎟│
//  ╎C│              ╎⎝C⎠│                    ╎C│              ╎⎝C⎠│
//  ┟─┘              ┟───┘                    ┟─┘              ┟───┘
//  ┗━━━━━━━━━━━━━━━━┛                        ┗━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">distributeL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: (</span><span class="type-name">A</span><span> |*| (</span><span class="type-name">B</span><span> |+| </span><span class="type-name">C</span><span>)) -⚬ ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |+| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>))
</span><span class="keyword">def</span><span> </span><span class="declaration-name">distributeR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">C</span><span>) -⚬ ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) |+| (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>))</span></code></pre>
        <p>These are primitives (actually, one of them is sufficient thanks to symmetry of ⊗).
        Note that arrows in the opposite direction need not be primitives, as they are always available:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">factorL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |+| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>)) -⚬ (</span><span class="type-name">A</span><span> |*| (</span><span class="type-name">B</span><span> |+| </span><span class="type-name">C</span><span>)) =
  </span><span class="identifier">either</span><span>(</span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">injectL</span><span>), </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">injectR</span><span>))

</span><span class="keyword">def</span><span> </span><span class="declaration-name">factorR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) |+| (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>)) -⚬ ((</span><span class="type-name">A</span><span> |+| </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">C</span><span>) =
  </span><span class="identifier">either</span><span>(</span><span class="identifier">par</span><span>(</span><span class="identifier">injectL</span><span>, </span><span class="identifier">id</span><span>), </span><span class="identifier">par</span><span>(</span><span class="identifier">injectR</span><span>, </span><span class="identifier">id</span><span>))</span></code></pre>
        
        <h2 id="co-distributivity-of-over" class="section"><a class="anchor-link left" href="#co-distributivity-of-over"><i class="icofont-laika">&#xef71;</i></a>Co-distributivity of ⊗ over &amp;</h2>
        <p>The tensor product ⊗ distributes over &amp; as well, only in the opposite (right-to-left) direction.
        This is consistent with the choice being made on the right of <code>A |&amp;| B</code> and being propagated to the left.
        It is therefore helpful to read the following components from right to left to see how one out-port is being distributed
        over the choice in the other out-port.</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━━━━━━┓                        ┏━━━━━━━━━━━━━━━━━━━┓
//  ┞───┐               ┞─┐                      ┞───┐               ┞─┐
//  ╎⎛A⎞│               ╎A│                      ╎⎛A⎞│               ╎A│
//  ╎⎜⊗⎟│               ┟─┘                      ╎⎜⊗⎟│               ╎&amp;│
//  ╎⎝B⎠│               ┃                        ╎⎝C⎠│               ╎B│
//  ╎ &amp; │ coDistributeL ┞─┐                      ╎ &amp; │ coDistributeR ┟─┘
//  ╎⎛A⎞│               ╎B│                      ╎⎛B⎞│               ┃
//  ╎⎜⊗⎟│               ╎&amp;│                      ╎⎜⊗⎟│               ┞─┐
//  ╎⎝C⎠│               ╎C│                      ╎⎝C⎠│               ╎C│
//  ┟───┘               ┟─┘                      ┟───┘               ┟─┘
//  ┗━━━━━━━━━━━━━━━━━━━┛                        ┗━━━━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">coDistributeL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |&amp;| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>)) -⚬ (</span><span class="type-name">A</span><span> |*| (</span><span class="type-name">B</span><span> |&amp;| </span><span class="type-name">C</span><span>))
</span><span class="keyword">def</span><span> </span><span class="declaration-name">coDistributeR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) |&amp;| (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>)) -⚬ ((</span><span class="type-name">A</span><span> |&amp;| </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">C</span><span>)</span></code></pre>
        <p>The intuition behind <code>coDistributeL</code> above is this: Only after the choice between <code>B</code> and <code>C</code> is made (from the right)
        is it decided how the <code>A</code> on the other out-port is produced, namely, whether it is the <code>A</code> from <code>A ⊗ B</code> or the <code>A</code> from
        <code>A ⊗ C</code>.</p>
        <p>At least one of these needs to be a primitive (the other one can be obtained thanks to symmetry of ⊗).
        Note that arrows in the opposite direction need not be primitives, as they are always available:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">coFactorL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: (</span><span class="type-name">A</span><span> |*| (</span><span class="type-name">B</span><span> |&amp;| </span><span class="type-name">C</span><span>)) -⚬ ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |&amp;| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>)) =
  </span><span class="identifier">choice</span><span>(</span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">chooseL</span><span>), </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">chooseR</span><span>))

</span><span class="keyword">def</span><span> </span><span class="declaration-name">coFactorR</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]: ((</span><span class="type-name">A</span><span> |&amp;| </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">C</span><span>) -⚬ ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">C</span><span>) |&amp;| (</span><span class="type-name">B</span><span> |*| </span><span class="type-name">C</span><span>)) =
  </span><span class="identifier">choice</span><span>(</span><span class="identifier">par</span><span>(</span><span class="identifier">chooseL</span><span>, </span><span class="identifier">id</span><span>), </span><span class="identifier">par</span><span>(</span><span class="identifier">chooseR</span><span>, </span><span class="identifier">id</span><span>))</span></code></pre>
        
        <h2 id="linearity-and-point-free-style" class="section"><a class="anchor-link left" href="#linearity-and-point-free-style"><i class="icofont-laika">&#xef71;</i></a>Linearity and point-free style</h2>
        <p>When composing components into larger components, it would be undesirable if somewhere inside a composite component
        some ports remained unconnected or accidentally connected multiple times.</p>
        <p>The property of each port being connected exactly once is called <em>linearity</em>—data and resources flow through the system
        in a linear fashion, without being duplicated or ignored (except via explicit operators for precisely that purpose).</p>
        <p><em>In Libretto, linearity is ensured by construction.</em>
        Data types used to represent Libretto programs are simply unable to represent non-linear programs.
        Notice how in composition operations, each port of a sub-program either is connected (and thus absent
        from the resulting program&#39;s interface) or becomes a port of the resulting composite program.</p>
        <p>Notice how the way we have been composing Libretto programs so far is like composing Scala functions in <em>point-free style,</em>
        i.e. when one defines functions by composing smaller functions, without ever referring to the function&#39;s input variables.
        For a moment, forget the differences between <code>-⚬</code> and <code>=&gt;</code> and view in-ports as function inputs.
        In Libretto, we define the (linear) function without ever having access to the inputs as Scala values.
        Indeed, user code will never have access to values of types like <code>One</code>, <code>Done</code>, <code>Need</code>, <code>A |*| B</code>, <code>A |+| B</code>, <code>A &amp; B</code>
        or others that we will encounter later<sup>(*)</sup>. If it did, it would break linearity,
        because Scala functions can freely ignore or duplicate (references to) values.</p>
        <p><em>Using point-free composition guarantees linearity at compile-time.</em></p>
        <p><sup>(*)</sup> Moreover, not only are values of the above types not accessible to a user, the types themselves may be uninhabited.
        Indeed, they are all uninhabited in the proof-of-concept implementation. This should not be
        surprising when you realize that Libretto&#39;s linear functions are mere blueprints. What then flows in a running system
        when the blueprint is executed need not be values of the auxiliary formal types used in blueprints.</p>
        
        <h2 id="λ-syntax" class="section"><a class="anchor-link left" href="#λ-syntax"><i class="icofont-laika">&#xef71;</i></a>λ-Syntax</h2>
        <p>Although point-free composition has the desirable property of ensuring linearity at compile-time,
        it can be quite cumbersome. It takes a lot of effort to just say which out-port should be connected
        to which in-port.</p>
        <p>That is something that would be easier in a point-full style: just name the ports and &quot;pass&quot;
        them to functions to obtain new ports. No explicit <code>swap</code>s or re-associations that obscure the essence
        of the program. That is what <em>lambda expressions</em> are for.</p>
        <p>Let&#39;s illustrate lambda expressions on an example.</p>
        <p>Suppose we want to implement a function <code>reorg</code> that just reorganizes its in-ports:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">reorg</span><span>: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |*| (</span><span class="type-name">C</span><span> |*| </span><span class="type-name">D</span><span>)) -⚬ (((</span><span class="type-name">C</span><span> |*| </span><span class="type-name">A</span><span>) |*| </span><span class="type-name">D</span><span>) |*| </span><span class="type-name">B</span><span>) =
  ???</span></code></pre>
        <p>For comparison, let&#39;s first do it in point-free style:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">reorg</span><span>: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |*| (</span><span class="type-name">C</span><span> |*| </span><span class="type-name">D</span><span>)) -⚬ (((</span><span class="type-name">C</span><span> |*| </span><span class="type-name">A</span><span>) |*| </span><span class="type-name">D</span><span>) |*| </span><span class="type-name">B</span><span>) =
  </span><span class="identifier">fst</span><span>(</span><span class="identifier">swap</span><span>) &gt; </span><span class="identifier">assocLR</span><span> &gt; </span><span class="identifier">swap</span><span> &gt; </span><span class="identifier">fst</span><span>(</span><span class="identifier">assocRL</span><span> &gt; </span><span class="identifier">fst</span><span>(</span><span class="identifier">swap</span><span>))</span></code></pre>
        <p>Well, it is a one-liner, but it is not immediately clear what it does.</p>
        <p>Let&#39;s now use a λ-expression instead:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">reorg</span><span>: ((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |*| (</span><span class="type-name">C</span><span> |*| </span><span class="type-name">D</span><span>)) -⚬ (((</span><span class="type-name">C</span><span> |*| </span><span class="type-name">A</span><span>) |*| </span><span class="type-name">D</span><span>) |*| </span><span class="type-name">B</span><span>) =
  λ { </span><span class="keyword">case</span><span> ((</span><span class="identifier">a</span><span> |*| </span><span class="identifier">b</span><span>) |*| (</span><span class="identifier">c</span><span> |*| </span><span class="identifier">d</span><span>)) =&gt; (((</span><span class="identifier">c</span><span> |*| </span><span class="identifier">a</span><span>) |*| </span><span class="identifier">d</span><span>) |*| </span><span class="identifier">b</span><span>) }</span></code></pre>
        <p>Opinions may vary, but I would say the λ version is more readable.</p>
        
        <h3 id="how-it-works" class="section"><a class="anchor-link left" href="#how-it-works"><i class="icofont-laika">&#xef71;</i></a>How it works</h3>
        <p>But what is going on here? A moment ago we said that we don&#39;t ever access inputs
        of a Libretto function as Scala values, yet here we construct a Libretto function</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span>((</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) |*| (</span><span class="type-name">C</span><span> |*| </span><span class="type-name">D</span><span>)) -⚬ (((</span><span class="type-name">C</span><span> |*| </span><span class="type-name">A</span><span>) |*| </span><span class="type-name">D</span><span>) |*| </span><span class="type-name">B</span><span>)</span></code></pre>
        <p>from a Scala function</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span>{ </span><span class="keyword">case</span><span> ((</span><span class="identifier">a</span><span> |*| </span><span class="identifier">b</span><span>) |*| (</span><span class="identifier">c</span><span> |*| </span><span class="identifier">d</span><span>)) =&gt; (((</span><span class="identifier">c</span><span> |*| </span><span class="identifier">a</span><span>) |*| </span><span class="identifier">d</span><span>) |*| </span><span class="identifier">b</span><span>) }</span></code></pre>
        <p>Let&#39;s look at the type signature of <code>λ</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> λ[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">A</span><span>] =&gt; </span><span class="identifier">$</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span></code></pre>
        <p>Indeed, it takes a Scala function and returns a Libretto function.
        Notice, however, that to create a Libretto function <code>A -⚬ B</code>,
        it takes a Scala function <code>$[A] =&gt; $[B]</code>. In particular, the Scala function
        does not have access to a value of type <code>A</code>. It has access to <code>$[A]</code>, which
        is an auxiliary type that exists at the meta level only.</p>
        <p>The programmer&#39;s task is to construct an expression of type <code>$[B]</code> from an expression of type <code>$[A]</code>.
        The implementation of <code>λ</code> then analyzes the resulting <code>$[B]</code> expression (which contains occurrences
        of the input variable <code>$[A]</code>) and infers a (point-free) Libretto function <code>A -⚬ B</code>.</p>
        
        <h3 id="operations-on-expressions" class="section"><a class="anchor-link left" href="#operations-on-expressions"><i class="icofont-laika">&#xef71;</i></a>Operations on $-expressions</h3>
        <pre><code class="nohighlight"><span class="comment">// given
</span><span class="keyword">val</span><span> </span><span class="identifier">a</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">A</span><span>]     = ???
</span><span class="keyword">val</span><span> </span><span class="identifier">b</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">B</span><span>]     = ???
</span><span class="keyword">val</span><span> </span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span><span>   = ???
</span><span class="keyword">val</span><span> </span><span class="identifier">g</span><span>: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">D</span><span> = ???
</span><span class="keyword">val</span><span> </span><span class="identifier">h</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">One</span><span> = ???

</span><span class="comment">// pair
</span><span class="keyword">val</span><span> </span><span class="identifier">ab</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>] = </span><span class="identifier">a</span><span> |*| </span><span class="identifier">b</span><span>

</span><span class="comment">// unpair
</span><span class="keyword">val</span><span> ((</span><span class="identifier">a1</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">A</span><span>]) |*| (</span><span class="identifier">b1</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">B</span><span>])) = </span><span class="identifier">ab</span><span>

</span><span class="comment">// pass to a Libretto function
</span><span class="keyword">val</span><span> </span><span class="identifier">c1</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">C</span><span>] = </span><span class="identifier">a</span><span> &gt; </span><span class="identifier">f</span><span>
</span><span class="comment">// or equivalently
</span><span class="keyword">val</span><span> </span><span class="identifier">c2</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">C</span><span>] = </span><span class="identifier">f</span><span>(</span><span class="identifier">a</span><span>)

</span><span class="comment">// shortcut for introducing something constructed from `One`
</span><span class="keyword">val</span><span> ((</span><span class="identifier">a2</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">A</span><span>]) |*| (</span><span class="identifier">d</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">D</span><span>])) = </span><span class="identifier">a</span><span> </span><span class="identifier">also</span><span> </span><span class="identifier">g</span><span>
</span><span class="comment">// equivalent to
</span><span class="identifier">a</span><span> &gt; </span><span class="identifier">introSnd</span><span> &gt; </span><span class="identifier">snd</span><span>(</span><span class="identifier">g</span><span>)

</span><span class="comment">// shortcut for eliminating `$[One]`
</span><span class="keyword">val</span><span> </span><span class="identifier">a3</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">a</span><span> </span><span class="identifier">alsoElim</span><span> </span><span class="identifier">h</span><span>(</span><span class="identifier">b</span><span>)
</span><span class="comment">// equivalent to
</span><span>(</span><span class="identifier">a</span><span> |*| </span><span class="identifier">h</span><span>(</span><span class="identifier">b</span><span>)) &gt; </span><span class="identifier">elimSnd</span></code></pre>
        
        <h3 id="linearity-checking" class="section"><a class="anchor-link left" href="#linearity-checking"><i class="icofont-laika">&#xef71;</i></a>Linearity checking</h3>
        <p>The Scala function <code>$[A] =&gt; $[B]</code> passed to <code>λ</code> is not guaranteed to be linear,
        i.e. it may use some part of input more than once or not at all.</p>
        <p>Remember that a Libretto function <code>A -⚬ B</code> can represent only linear functions.
        If a non-linear Scala function is passed to <code>λ</code>, it throws an error.
        Notice that this error is thrown at assembly time, i.e. when constructing
        the Libretto program, in particular, <em>before</em> running the Libretto program.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">overusedInput</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">A</span><span>) =
  λ { </span><span class="identifier">a</span><span> =&gt; </span><span class="identifier">a</span><span> |*| </span><span class="identifier">a</span><span> }
</span><span class="comment">// libretto.impl.FreeScalaDSL$NotLinearException: Variables used more than once: 
//  - The input of lambda expression ending at basics.md:233
// 
// 	at libretto.impl.FreeScalaDSL$.λ(FreeScalaDSL.scala:447)
// 	at libretto.impl.FreeScalaDSL$.λ(FreeScalaDSL.scala:437)
// 	at repl.MdocSession$App.$init$$$anonfun$1(basics.md:233)
// 	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">unusedInput</span><span>: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">A</span><span> =
  λ { </span><span class="keyword">case</span><span> (</span><span class="identifier">a</span><span> |*| </span><span class="identifier">b</span><span>) =&gt; </span><span class="identifier">a</span><span> }
</span><span class="comment">// libretto.impl.FreeScalaDSL$NotLinearException: Variables not fully consumed: 
//  - The second half of untupling at basics.md:244
// 
// 	at libretto.impl.FreeScalaDSL$.λ(FreeScalaDSL.scala:448)
// 	at libretto.impl.FreeScalaDSL$.λ(FreeScalaDSL.scala:437)
// 	at repl.MdocSession$App.$init$$$anonfun$2(basics.md:244)
// 	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)</span></code></pre>
        <p>It is trivial to do linearity checking of programs constructed using λ-expressions in tests.
        The test just needs to assemble the program without throwing an exception.</p>
        <p>If this is the main program</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">MyApp</span><span> {
  </span><span class="keyword">import</span><span> </span><span class="identifier">scala</span><span>.</span><span class="identifier">concurrent</span><span>.</span><span class="identifier">duration</span><span>.</span><span class="identifier">_</span><span>

  </span><span class="keyword">val</span><span> </span><span class="identifier">prg</span><span>: </span><span class="type-name">Done</span><span> -⚬ </span><span class="type-name">Done</span><span> =
    λ { </span><span class="identifier">start</span><span> =&gt;
      </span><span class="comment">// some complex program composed of many sub-programs
</span><span>      </span><span class="identifier">start</span><span> &gt; </span><span class="identifier">delay</span><span>(</span><span class="number-literal">1</span><span>.</span><span class="identifier">hour</span><span>)
    }
}</span></code></pre>
        <p>then in tests it is sufficient to just access the <code>val</code> holding the program to check that
        it can be successfully constructed.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="type-name">MyApp</span><span>.</span><span class="identifier">prg</span></code></pre>
        <p>If the program is constructed at all, it will not throw a linearity error at runtime.</p>
        
        <h2 id="recursion" class="section"><a class="anchor-link left" href="#recursion"><i class="icofont-laika">&#xef71;</i></a>Recursion</h2>
        
        <h3 id="recursive-types" class="section"><a class="anchor-link left" href="#recursive-types"><i class="icofont-laika">&#xef71;</i></a>Recursive types</h3>
        <p>To define recursive port-types, there is <code>Rec[F[_]]</code> type constructor provided as a primitive:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]]

</span><span class="comment">/** Hides one level of a recursive type definition. */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">pack</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]]: </span><span class="type-name">F</span><span>[</span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>]] -⚬ </span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>]

</span><span class="comment">/** Unpacks one level of a recursive type definition. */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">unpack</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]]: </span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>] -⚬ </span><span class="type-name">F</span><span>[</span><span class="type-name">Rec</span><span>[</span><span class="type-name">F</span><span>]]</span></code></pre>
        <p>(Note that <code>Rec</code> is analogous to the <a href="https://hackage.haskell.org/package/data-fix-0.3.1/docs/Data-Fix.html">Fix</a> type
        constructor.)</p>
        <p>You can roughly think of the abstract type <code>Rec[F[_]]</code> as if it was a recursive type alias <code>type Rec[F[_]] = F[Rec[F]]</code>.
        We just have to do the substitution in either direction explicitly via <code>pack</code> and <code>unpack</code>.</p>
        <p>As an example, let&#39;s define a <code>List</code> type:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//         +-------- element type
//         |    +--- marks occurrences of recursive substructure(s), in this case the tail sub-list
//         |    |     +-- nil     +-- cons
//         |    |     | head --+  |   +-- tail
//         |    |     |        |  |   |
//         V    V     V        V  V   V
</span><span class="keyword">type</span><span> </span><span class="type-name">ListF</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">Self</span><span>] = </span><span class="type-name">One</span><span> |+| (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">Self</span><span>)
</span><span class="keyword">type</span><span> </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="type-name">Rec</span><span>[</span><span class="type-name">ListF</span><span>[</span><span class="type-name">A</span><span>, *]] </span><span class="comment">// the * is kind-projector syntax for type lambdas,</span></code></pre>
        <p>and the <code>nil</code> and <code>cons</code> constructors:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">List</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">nil</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">One</span><span> -⚬ </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] =
    </span><span class="identifier">injectL</span><span> &gt; </span><span class="identifier">pack</span><span>[</span><span class="type-name">ListF</span><span>[</span><span class="type-name">A</span><span>, *]]

  </span><span class="comment">//     head --+       +-- tail
</span><span>  </span><span class="comment">//            |       |
</span><span>  </span><span class="comment">//            V       V
</span><span>  </span><span class="keyword">def</span><span> </span><span class="declaration-name">cons</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>]) -⚬ </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] =
    </span><span class="identifier">injectR</span><span> &gt; </span><span class="identifier">pack</span><span>[</span><span class="type-name">ListF</span><span>[</span><span class="type-name">A</span><span>, *]]
}</span></code></pre>
        <p>Notes:</p>
        <ul>
          <li>Such a <code>List</code> may be produced gradually. For example, one may use the <code>cons</code> constructor where the tail is not yet
          known to be either empty or non-empty. Consequently, the head of a list can already be accessed and consumed (e.g.
          by the <code>map</code> function defined below) while the tail is still being constructed.
          This is different from <code>scala.List</code> where in <code>val xs = head :: tail</code> the <code>tail</code> is fully constructed before <code>xs</code>
          is constructed and its head made accessible for further processing.</li>
          <li>Consequently, <code>List</code>s may be infinite and it is not a problem if the elements are consumed at a faster rate than
          they are produced.</li>
          <li>Note that unlike infinite lazy lists in Haskell, the construction of further elements is driven by the <code>List</code>
          producer, not by the <code>List</code> consumer.</li>
        </ul>
        
        <h3 id="recursive-functions" class="section"><a class="anchor-link left" href="#recursive-functions"><i class="icofont-laika">&#xef71;</i></a>Recursive functions</h3>
        <p>To work with recursive structures we need recursive functions.</p>
        <p>The general recipe for handling a recursive type <code>Rec[F]</code> is</p>
        <ol class="arabic">
          <li>&quot;Pretend&quot; we already know how to handle the nested <code>Rec[F]</code> substructure(s).</li>
          <li>Unpack one level of the recursive definition to obtain <code>F[Rec[F]</code>.</li>
          <li>Write code to handle <code>F[Rec[F]]</code>, using the made up linear function to handle nested occurrences of <code>Rec[F]</code>.</li>
        </ol>
        <p>The &quot;pretending&quot; is done by taking a linear function as an argument. More concretely, instead of constructing a linear
        function <code>Rec[F] -⚬ B</code> directly, we write a Scala function <code>(Rec[F] -⚬ B) =&gt; (Rec[F] -⚬ B)</code> that constructs the desired
        linear function given a linear function of the same signature that it can use to handle substructures. Such Scala
        function can then be passed to the primitive <code>rec</code> function that &quot;ties the loop&quot; and produces the desired linear
        function <code>Rec[F] -⚬ B</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">rec</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: (</span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>) =&gt; (</span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>)): </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span></code></pre>
        <p>As an example, let&#39;s define a linear function that applies a given linear function to each element of a <code>List</code>
        (defined above).</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">List</span><span> {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">map</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">List</span><span>[</span><span class="type-name">B</span><span>] = {
    </span><span class="comment">//                         +-- pretending we already know how to map the tail
</span><span>    </span><span class="comment">//                         |
</span><span>    </span><span class="comment">//                         V
</span><span>    </span><span class="identifier">rec</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">List</span><span>[</span><span class="type-name">B</span><span>]] { (</span><span class="identifier">mapTail</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">List</span><span>[</span><span class="type-name">B</span><span>]) =&gt;
      </span><span class="identifier">unpack</span><span> &gt; </span><span class="identifier">either</span><span>(
        </span><span class="identifier">nil</span><span>[</span><span class="type-name">B</span><span>],
        </span><span class="identifier">par</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">mapTail</span><span>) &gt; </span><span class="identifier">cons</span><span>[</span><span class="type-name">B</span><span>],
      )
    }
  }
}</span></code></pre>
        <p>Notes:</p>
        <ul>
          <li><code>par(f, mapTail)</code> maps the head and the tail of the list concurrently.</li>
          <li>The <code>cons[B]</code> constructor may execute as soon as the input list is known to be non-empty.
          In particular, it does not wait for <code>par(f, mapTail)</code> to finish.</li>
        </ul>
        
        <h2 id="racing" class="section"><a class="anchor-link left" href="#racing"><i class="icofont-laika">&#xef71;</i></a>Racing</h2>
        <p>Libretto provides functions for testing which of two concurrent signals arrived first.</p>
        <p>The two basic racing operations are on dismissible signals, <code>Ping</code> and <code>Pong</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">racePair</span><span>   : (</span><span class="type-name">Ping</span><span> |*| </span><span class="type-name">Ping</span><span>) -⚬ (</span><span class="type-name">One</span><span> |+| </span><span class="type-name">One</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">selectPair</span><span> : (</span><span class="type-name">One</span><span> |&amp;| </span><span class="type-name">One</span><span>) -⚬ (</span><span class="type-name">Pong</span><span> |*| </span><span class="type-name">Pong</span><span>)</span></code></pre>
        <p>In <code>racePair</code>, the two <code>Ping</code> signals from the in-port race against each other.
        If the first signal wins, the output will be left.
        If the second signal wins, the output will be right.</p>
        <p>In <code>selectPair</code>, the two <code>Pong</code> signals from the <em>out</em>-port race against each other.
        If the first signal wins, left will be chosen from the input.
        If the second signal wins, right will be chosen from the input.</p>
        <p>In both cases, both signals are consumed: the winning one has fired, the slower one is dismissed.</p>
        <p>Only one of these operations needs to be a primitive, the other one is derivable using signal inversions discussed above.</p>
        <p>There are also versions for non-dismissible signals (<code>Done</code> and <code>Need</code>):</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">raceDone</span><span>   : (</span><span class="type-name">Done</span><span> |*| </span><span class="type-name">Done</span><span>) -⚬ (</span><span class="type-name">Done</span><span> |+| </span><span class="type-name">Done</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">selectNeed</span><span> : (</span><span class="type-name">Need</span><span> |&amp;| </span><span class="type-name">Need</span><span>) -⚬ (</span><span class="type-name">Need</span><span> |*| </span><span class="type-name">Need</span><span>)</span></code></pre>
        <p>The main difference is that only the winning signal is consumed by the race.
        The slower signal still has to be awaited at some point, so it is propagated to the other side of <code>-⚬</code>:</p>
        <ul>
          <li>In <code>raceDone</code>, if the first <code>Done</code> signal of the in-port wins, the second one is returned on the left of the <code>|+|</code>
          in the out-port. The case of second signal winning is analogous.</li>
          <li>In <code>selectNeed</code>, if the first <code>Need</code> signal of the <em>out</em>-port wins, the left side of the <code>|&amp;|</code> in the in-port is
          chosen and the second <code>Need</code> signal of the out-port is forwarded to it.</li>
        </ul>
        <p>There are additional library functions for racing built on top of these, provided for convenience.</p>
        
        <h3 id="racing-is-a-source-of-non-determinism" class="section"><a class="anchor-link left" href="#racing-is-a-source-of-non-determinism"><i class="icofont-laika">&#xef71;</i></a>Racing is a source of non-determinism</h3>
        <p>The order of two concurrently occurring events is undefined. The outcome of a racing operation on two concurrent events
        will therefore be non-deterministic. The non-determinism is propagated by proceeding differently for different winners
        of the race.</p>
        
        <h2 id="using-scala-values-and-functions" class="section"><a class="anchor-link left" href="#using-scala-values-and-functions"><i class="icofont-laika">&#xef71;</i></a>Using Scala values and functions</h2>
        <p>Libretto provides means to use <em>immutable</em> Scala values and <em>total</em> Scala functions in Libretto programs.</p>
        <p>The type <code>Val[A]</code> represents a Scala value of type <code>A</code> flowing in the positive direction (i.e. along the <code>-⚬</code>).
        Similarly, the type <code>Neg[A]</code> represents a Scala value of type <code>A</code> flowing in the negative direction
        (i.e. against the <code>-⚬</code>).</p>
        <p>For a first approximation, <code>Val[A]</code> can be thought of as <code>Future[A]</code> and <code>Neg[A]</code> can be thought of as <code>Promise[A]</code>.</p>
        <p>To initially get some Scala values into a Libretto program, we bake them in during assembly using the primitives</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">constVal</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">a</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">Done</span><span> -⚬ </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>]
</span><span class="keyword">def</span><span> </span><span class="declaration-name">constNeg</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">a</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">Need</span></code></pre>
        <p>Notice the incoming signals, <code>Done</code> and <code>Need</code>, respectively. Given that signals cannot be ignored, the responsibility
        to handle a signal is transformed into a responsibility to handle a Scala value. This is OK, because Scala values cannot
        be completely ignored, either. Doing so would mean to lose track of an ongoing potentially expensive computation and
        thus a resource leak.</p>
        <p>However, the particular value inside <code>Val</code> or <code>Neg</code> can be ignored; we just have to keep the liability to await the
        computation. For this purpose, there are primitives to convert Scala values into signals:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">neglect</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">Done</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">inflate</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">Need</span><span> -⚬ </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
        <p>On the other hand, values can be duplicated, using</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">dup</span><span>   [</span><span class="type-name">A</span><span>]: </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] -⚬ (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>])
</span><span class="keyword">def</span><span> </span><span class="declaration-name">dupNeg</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]) -⚬ </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
        <p>Because of this ability to duplicate values, it is preferable to use only <em>immutable</em> values.</p>
        <p>To apply a Scala function to a Scala value inside a Libretto program, we can use one of the primitives</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span>       </span><span class="declaration-name">mapVal</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>): </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] -⚬ </span><span class="type-name">Val</span><span>[</span><span class="type-name">B</span><span>]
</span><span class="keyword">def</span><span> </span><span class="declaration-name">contramapNeg</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>): </span><span class="type-name">Neg</span><span>[</span><span class="type-name">B</span><span>] -⚬ </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
        <p>Note that the Scala functions used must be <em>total,</em> that is they must always terminate and never throw an exception.</p>
        <p>It is preferable that the used functions also be <em>pure,</em> but benign side-effects are OK. Just note that it is undefined
        on which thread the function will execute, and that it may as well not execute at all.</p>
        <p>We can convert between Scala pairs and Libretto concurrent pairs using</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span>   </span><span class="declaration-name">liftPair</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">Val</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)] -⚬ (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Val</span><span>[</span><span class="type-name">B</span><span>])
</span><span class="keyword">def</span><span> </span><span class="declaration-name">unliftPair</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Val</span><span>[</span><span class="type-name">B</span><span>]) -⚬ </span><span class="type-name">Val</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)]

</span><span class="keyword">def</span><span>   </span><span class="declaration-name">liftNegPair</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">Neg</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)] -⚬ (</span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Neg</span><span>[</span><span class="type-name">B</span><span>])
</span><span class="keyword">def</span><span> </span><span class="declaration-name">unliftNegPair</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: (</span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Neg</span><span>[</span><span class="type-name">B</span><span>]) -⚬ </span><span class="type-name">Neg</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>)]</span></code></pre>
        <p>We can lift a decision made by Scala code into Libretto via</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">liftEither</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: </span><span class="type-name">Val</span><span>[</span><span class="type-name">Either</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]] -⚬ (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |+| </span><span class="type-name">Val</span><span>[</span><span class="type-name">B</span><span>])</span></code></pre>
        <p>Just like signals, the direction of Scala values can be inverted:</p>
        <pre><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━━━┓                   ┏━━━━━━━━━━━━━━━┓
//  ┃  promise[A]   ┃                   ┃  fulfill[A]   ┃
//  ┃               ┞──────┐            ┞──────┐        ┃
//  ┃            ┌┄┄╎Neg[A]│←┄        ┄→╎Val[A]│┄┄┐     ┃
//  ┃            ┆  ┟──────┘            ┟──────┘  ┆     ┃
//  ┃            ┆  ┃                   ┃         ┆     ┃
//  ┃            ┆  ┞──────┐            ┞──────┐  ┆     ┃
//  ┃            └┄→╎Val[A]│┄→        ←┄╎Neg[A]│←┄┘     ┃
//  ┃               ┟──────┘            ┟──────┘        ┃
//  ┗━━━━━━━━━━━━━━━┛                   ┗━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">promise</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">One</span><span> -⚬ (</span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>])
</span><span class="keyword">def</span><span> </span><span class="declaration-name">fulfill</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">Val</span><span>[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">Neg</span><span>[</span><span class="type-name">A</span><span>]) -⚬ </span><span class="type-name">One</span></code></pre>
        
        <h2 id="inverse-types" class="section"><a class="anchor-link left" href="#inverse-types"><i class="icofont-laika">&#xef71;</i></a>Inverse Types</h2>
        <p>We have seen that some types of interaction come in pairs, where one is the inverse of the other,
        meaning that the information flow in one is exactly opposite the information flow in the other.</p>
        <p>Examples that we have encountered so far:</p>
        <table>
          <thead>
            <tr>
              <th>type</th>
              <th>inverse type</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Done</code></td>
              <td><code>Need</code></td>
            </tr>
            <tr>
              <td><code>Ping</code></td>
              <td><code>Pong</code></td>
            </tr>
            <tr>
              <td><code>Val[A]</code></td>
              <td><code>Neg[A]</code></td>
            </tr>
            <tr>
              <td><code>One</code></td>
              <td><code>One</code></td>
            </tr>
          </tbody>
        </table>
        <p>We can obtain bigger types that are inverses of each other by forming concurrent pairs:</p>
        <table>
          <thead>
            <tr>
              <th>type</th>
              <th>inverse type</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Done |*| Ping</code></td>
              <td><code>Need |*| Pong</code></td>
            </tr>
            <tr>
              <td><code>Val[A] |*| (Neg[B] |*| Need)</code></td>
              <td><code>Neg[A] |*| (Val[B] |*| Done)</code></td>
            </tr>
            <tr>
              <td>...</td>
              <td>...</td>
            </tr>
          </tbody>
        </table>
        
        <h3 id="duality-of-and" class="section"><a class="anchor-link left" href="#duality-of-and"><i class="icofont-laika">&#xef71;</i></a>Duality of ⊕ and &amp;</h3>
        <p>⊕ and &amp; are also inverses of each other:
         - in <code>A |+| B</code>, the decision of which branch will proceed is passed from left to right;
         - in <code>A |&amp;| B</code>, the decision is passed from right to left.</p>
        <table>
          <thead>
            <tr>
              <th>type</th>
              <th>inverse type</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Done |+| Val[A]</code></td>
              <td><code>Need |&amp;| Neg[A]</code></td>
            </tr>
            <tr>
              <td>...</td>
              <td>...</td>
            </tr>
          </tbody>
        </table>
        
        <h3 id="universal-inversions" class="section"><a class="anchor-link left" href="#universal-inversions"><i class="icofont-laika">&#xef71;</i></a>Universal Inversions</h3>
        <p>There is a special type constructor, <code>-[_]</code>, whose meaning is that <code>-[A]</code> is the inverse of <code>A</code>.
        We also say that <code>-[A]</code> is a <em>demand</em> for <code>A</code>.</p>
        <p>It works universally for all types <code>A</code>.
        This is convenient, as to talk about the inverse of some complex type <code>A</code>
        we don&#39;t have to manually spell out what its inverse would be.
        We can just use <code>-[A]</code> to refer to the inverse of <code>A</code>.</p>
        <p>The downside is that types now have two inverses.
        For example, both <code>Need</code> and <code>-[Done]</code> are inverses of <code>Done</code>.
        However, these are isomorphic and one can go back and forth between these
        without changing the semantics of the program.</p>
        <p>There are some primitive operations for working with inverses.</p>
        <pre><code>  ┏━━━━━━━━━━━┓               ┏━━━━━━━━━━━━━┓
  ┃ demand[A] ┃               ┃  supply[A]  ┃
  ┃           ┞────┐          ┞────┐        ┃
  ┃        ┌┄┄╎-[A]│          ╎  A │┄┄┐     ┃
  ┃        ┆  ┟────┘          ┟────┘  ┆     ┃
  ┃        ┆  ┃               ┃       ┆     ┃
  ┃        ┆  ┞────┐          ┞────┐  ┆     ┃
  ┃        └┄→╎  A │          ╎-[A]│←┄┘     ┃
  ┃           ┟────┘          ┟────┘        ┃
  ┗━━━━━━━━━━━┛               ┗━━━━━━━━━━━━━┛</code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">demand</span><span>[</span><span class="type-name">A</span><span>]: </span><span class="type-name">One</span><span> -⚬ (-[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">A</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">supply</span><span>[</span><span class="type-name">A</span><span>]: (</span><span class="type-name">A</span><span> |*| -[</span><span class="type-name">A</span><span>]) -⚬ </span><span class="type-name">One</span></code></pre>
        <p>Notice the similarity with the inverting operations that we have seen before:</p>
        <pre><code>  demand[A]            promise[A]             lInvertSignal        lInvertPongPing
┏━━━━━━━━━━━┓        ┏━━━━━━━━━━━┓            ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓
┃           ┞────┐   ┃           ┞──────┐     ┃          ┞────┐    ┃          ┞────┐
┃        ┌┄┄╎-[A]│   ┃        ┌┄┄╎Neg[A]│←┄   ┃       ┌┄┄╎Need│←┄  ┃       ┌┄┄╎Pong│←┄
┃        ┆  ┟────┘   ┃        ┆  ┟──────┘     ┃       ┆  ┟────┘    ┃       ┆  ┟────┘
┃        ┆  ┃        ┃        ┆  ┃            ┃       ┆  ┃         ┃       ┆  ┃
┃        ┆  ┞────┐   ┃        ┆  ┞──────┐     ┃       ┆  ┞────┐    ┃       ┆  ┞────┐
┃        └┄→╎  A │   ┃        └┄→╎Val[A]│┄→   ┃       └┄→╎Done│┄→  ┃       └┄→╎Ping│┄→
┃           ┟────┘   ┃           ┟──────┘     ┃          ┟────┘    ┃          ┟────┘
┗━━━━━━━━━━━┛        ┗━━━━━━━━━━━┛            ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛


   supply[A]            fulfill[A]            rInvertSignal       rInvertPingPong
┏━━━━━━━━━━━━━┓      ┏━━━━━━━━━━━━━━┓         ┏━━━━━━━━━━┓         ┏━━━━━━━━━━┓
┞────┐        ┃      ┞──────┐       ┃         ┞────┐     ┃         ┞────┐     ┃
╎  A │┄┄┐     ┃    ┄→╎Val[A]│┄┄┐    ┃       ┄→╎Done│┄┄┐  ┃       ┄→╎Ping│┄┄┐  ┃
┟────┘  ┆     ┃      ┟──────┘  ┆    ┃         ┟────┘  ┆  ┃         ┟────┘  ┆  ┃
┃       ┆     ┃      ┃         ┆    ┃         ┃       ┆  ┃         ┃       ┆  ┃
┞────┐  ┆     ┃      ┞──────┐  ┆    ┃         ┞────┐  ┆  ┃         ┞────┐  ┆  ┃
╎-[A]│←┄┘     ┃    ←┄╎Neg[A]│←┄┘    ┃       ←┄╎Need│←┄┘  ┃       ←┄╎Pong│←┄┘  ┃
┟────┘        ┃      ┟──────┘       ┃         ┟────┘     ┃         ┟────┘     ┃
┗━━━━━━━━━━━━━┛      ┗━━━━━━━━━━━━━━┛         ┗━━━━━━━━━━┛         ┗━━━━━━━━━━┛</code></pre>
        <p>Then there are primitives for splitting and joining inversions:</p>
        <pre><code>  demandSeparately        demandTogether
  ┏━━━━━━━━━━━┓           ┏━━━━━━━━━━━┓
  ┃           ┞────┐      ┞────┐      ┃
  ┞────┐      ╎-[A]│      ╎-[A]│      ┞────┐
  ╎ ⎡A⎤│      ┟────┘      ┟────┘      ╎ ⎡A⎤│
  ╎-⎢⊗⎥│      ┃           ┃           ╎-⎢⊗⎥│
  ╎ ⎣B⎦│      ┞────┐      ┞────┐      ╎ ⎣B⎦│
  ┟────┘      ╎-[B]│      ╎-[B]│      ┟────┘
  ┃           ┟────┘      ┟────┘      ┃
  ┗━━━━━━━━━━━┛           ┗━━━━━━━━━━━┛</code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">demandSeparately</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>] : -[</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>] -⚬ (-[</span><span class="type-name">A</span><span>] |*| -[</span><span class="type-name">B</span><span>])
</span><span class="keyword">def</span><span> </span><span class="declaration-name">demandTogether</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]   : (-[</span><span class="type-name">A</span><span>] |*| -[</span><span class="type-name">B</span><span>]) -⚬ -[</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>]</span></code></pre>
        <p>We can then derive other operations, like</p>
        <pre><code class="nohighlight"><span class="comment">/**
  * ┏━━━━━━━━━━━┯━━━━━━━━━┯━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━┓
  * ┞───┐       ├───┐     ├────┐      ├────┐              ┃
  * ╎--A│       ╎--A│     ╎--A │      ╎ -A │              ┃
  * ┟───┘       ├───┘     ╎  ⊗ │ swap ╎  ⊗ │ supply[-[A]] ┃
  * ┠╌╌╌╌╌╌╌╌╌╌╌┤ assocRL ╎ -A │      ╎--A │              ┃
  * ┃           ├───┐     ├────┘      ├────┘              ┃
  * ┃           ╎-A │     ├╌╌╌╌╌╌╌╌╌╌╌┴╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┨
  * ┃ demand[A] ╎ ⊗ │     ├───┐                           ┞───┐
  * ┃           ╎ A │     ╎ A │                           ╎ A │
  * ┃           ├───┘     ├───┘                           ┟───┘
  * ┗━━━━━━━━━━━┷━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  */</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">doubleDemandElimination</span><span>[</span><span class="type-name">A</span><span>]: -[-[</span><span class="type-name">A</span><span>]] -⚬ </span><span class="type-name">A</span><span> =
  </span><span class="identifier">introSnd</span><span>(</span><span class="identifier">demand</span><span>[</span><span class="type-name">A</span><span>]) &gt; </span><span class="identifier">assocRL</span><span> &gt; </span><span class="identifier">elimFst</span><span>(</span><span class="identifier">swap</span><span> &gt; </span><span class="identifier">supply</span><span>[-[</span><span class="type-name">A</span><span>]])</span></code></pre>
        <p>or the isomorphisms between <code>Need</code> and <code>-[Done]</code>, etc.</p>
        
        <h2 id="function-objects-and-higher-order-functions" class="section"><a class="anchor-link left" href="#function-objects-and-higher-order-functions"><i class="icofont-laika">&#xef71;</i></a>Function Objects and Higher-Order Functions</h2>
        <p>In modern programming languages we are used to functions being first-class objects
        that can be passed to or returned from other functions, so-called <em>higher-order functions.</em></p>
        <p>In Libretto, there, too, are function objects and higher-order functions.
        Unlike most functional programming languages, though, there is a syntactic distinction
        between</p>
        <ul>
          <li><em>function as code,</em> <code>-⚬</code>, which is a blueprint of a program, a value of the host language, and</li>
        </ul>
        <ul>
          <li><em>function object,</em> <code>=⚬</code>, which is a resource in a <em>running</em> program.</li>
        </ul>
        <p>It makes sense to distinguish between the two, as they exist at different stages.</p>
        <p>Note that <code>A =⚬ B</code> is <em>not</em> a value that can be freely used any number of times.
        It may have captured resources (i.e. it is a closure), and therefore must itself
        be treated as a resource that has to be consumed exactly once.</p>
        <p>Note that function <em>objects</em> are not objects in the OOP sense. We call them
        objects because</p>
        <ul>
          <li>they exist at the <em>object-level</em> (as opposed to the meta-level,
          where functions as code, <code>A -⚬ B</code>, exist);</li>
        </ul>
        <ul>
          <li>they are the <em>internal hom objects</em> in a monoidal category.</li>
        </ul>
        <p>Function objects are introduced by <code>curry</code> and eliminated by <code>eval</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">curry</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">C</span><span>): </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> =⚬ </span><span class="type-name">C</span><span>)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">eval</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: ((</span><span class="type-name">A</span><span> =⚬ </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">A</span><span>) -⚬ </span><span class="type-name">B</span></code></pre>
        <p>Or we could have chosen <code>uncurry</code> instead of <code>eval</code>, but they are reducible to each other:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">uncurry</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> =⚬ </span><span class="type-name">C</span><span>)): (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">C</span><span> =
  </span><span class="identifier">par</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">id</span><span>[</span><span class="type-name">B</span><span>]) &gt; </span><span class="identifier">eval</span><span>[</span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>]

</span><span class="keyword">def</span><span> </span><span class="declaration-name">eval</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: ((</span><span class="type-name">A</span><span> =⚬ </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">A</span><span>) -⚬ </span><span class="type-name">B</span><span> =
  </span><span class="identifier">uncurry</span><span>(</span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span> =⚬ </span><span class="type-name">B</span><span>])</span></code></pre>
        
        <h3 id="function-objects-via-inversions" class="section"><a class="anchor-link left" href="#function-objects-via-inversions"><i class="icofont-laika">&#xef71;</i></a>Function Objects via Inversions</h3>
        <p>Interestingly, function objects in Libretto are expressible via inversions, namely</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">type</span><span> =⚬[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>] = -[</span><span class="type-name">A</span><span>] |*| </span><span class="type-name">B</span></code></pre>
        <p>That&#39;s right, a function object <code>A =⚬ B</code> is just an interface of interaction which
        demands <code>A</code> and (eventually) supplies <code>B</code>.</p>
        <p>In particular, it is not a callback given to someone else to execute.
        Instead, each side of the interface does its respective part, namely
        the producer of <code>A =⚬ B</code> receives <code>A</code> and produces <code>B</code>, whereas
        the consumer of <code>A =⚬ B</code> produces <code>A</code> and receives <code>B</code>:</p>
        <pre><code>    A =⚬ B
  ━━━━┯━━━━━━━━
      ├───┐
    ←┄╎-A │←┄
      ├───┘
      ├───┐
    ┄→╎ B │┄→
      ├───┘
  ━━━━┷━━━━━━━━</code></pre>
        <p>Note that there is no requirement that <code>B</code> is produced only after <code>A</code> is supplied.
        The plain Scala analogue would be a pair <code>(Promise[A], Future[B])</code>. There
        is no requirement that the future completes only after the promise has been fulfilled.</p>
        <p><code>curry</code> and <code>eval</code> are expressible in terms of <code>demand</code> and <code>supply</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">curry</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">C</span><span>): </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> =⚬ </span><span class="type-name">C</span><span>) =
  </span><span class="identifier">introFst</span><span>(</span><span class="identifier">demand</span><span>[</span><span class="type-name">B</span><span>]) &gt; </span><span class="identifier">assocLR</span><span> &gt; </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>[-[</span><span class="type-name">B</span><span>]], </span><span class="identifier">swap</span><span> &gt; </span><span class="identifier">f</span><span>)

</span><span class="keyword">def</span><span> </span><span class="declaration-name">eval</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]: ((</span><span class="type-name">A</span><span> =⚬ </span><span class="type-name">B</span><span>) |*| </span><span class="type-name">A</span><span>) -⚬ </span><span class="type-name">B</span><span> =
  </span><span class="identifier">swap</span><span> &gt; </span><span class="identifier">assocRL</span><span> &gt; </span><span class="identifier">elimFst</span><span>(</span><span class="identifier">supply</span><span>[</span><span class="type-name">A</span><span>])</span></code></pre>
        
        <h3 id="λ-expressions" class="section"><a class="anchor-link left" href="#λ-expressions"><i class="icofont-laika">&#xef71;</i></a>Λ-expressions</h3>
        <p>Function objects can also be created using Λ-expressions (uppercase Greek letter Lambda),
        which are similar to λ-expressions introduced above.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> Λ[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">A</span><span>] =&gt; </span><span class="identifier">$</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="identifier">$</span><span>[</span><span class="type-name">A</span><span> =⚬ </span><span class="type-name">B</span><span>]</span></code></pre>
        <p>For comparison, here is the <code>λ</code> signature again:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> λ[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>: </span><span class="identifier">$</span><span>[</span><span class="type-name">A</span><span>] =&gt; </span><span class="identifier">$</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span></code></pre>
        <p>While <code>λ</code> creates a Libretto function, <code>Λ</code> creates just an auxiliary expression <code>$[A =⚬ B]</code>
        that can be used from the outer <code>λ</code> expression.</p>
        <p>For example, we could reimplement <code>curry</code> like this:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">myCurry</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">f</span><span>: (</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>) -⚬ </span><span class="type-name">C</span><span>): </span><span class="type-name">A</span><span> -⚬ (</span><span class="type-name">B</span><span> =⚬ </span><span class="type-name">C</span><span>) =
  λ { </span><span class="identifier">a</span><span> =&gt;
    Λ { </span><span class="identifier">b</span><span> =&gt;
      </span><span class="identifier">f</span><span>(</span><span class="identifier">a</span><span> |*| </span><span class="identifier">b</span><span>)
    }
  }</span></code></pre>
        <p>Notice how the <code>Λ</code>-expression captures the variable <code>a</code> from the outer scope, i.e. it is a closure.</p>
        <p>Note that capturing outer variables is not allowed for <code>λ</code>-expressions.</p>
        
        <h2 id="equality-of-libretto-programs" class="section"><a class="anchor-link left" href="#equality-of-libretto-programs"><i class="icofont-laika">&#xef71;</i></a>Equality of Libretto programs</h2>
        <p>There are equations (laws) that hold about Libretto arrows, such as</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">// given
</span><span class="keyword">val</span><span> </span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">B</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">C</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">h</span><span>: </span><span class="type-name">C</span><span> -⚬ </span><span class="type-name">D</span><span>

</span><span class="comment">// then
</span><span>
(</span><span class="identifier">f</span><span> &gt; </span><span class="identifier">g</span><span>) &gt; </span><span class="identifier">h</span><span> = </span><span class="identifier">f</span><span> &gt; (</span><span class="identifier">g</span><span> &gt; </span><span class="identifier">h</span><span>)

</span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span>] &gt; </span><span class="identifier">f</span><span> = </span><span class="identifier">f</span><span> = </span><span class="identifier">f</span><span> &gt; </span><span class="identifier">id</span><span>[</span><span class="type-name">B</span><span>]</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">id</span><span>[</span><span class="type-name">B</span><span>]) = </span><span class="identifier">id</span><span>[</span><span class="type-name">A</span><span> |*| </span><span class="type-name">B</span><span>]</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">// given
</span><span class="keyword">val</span><span> </span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> -⚬ </span><span class="type-name">C</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">g</span><span>: </span><span class="type-name">B</span><span> -⚬ </span><span class="type-name">C</span><span>

</span><span class="comment">// then
</span><span class="identifier">injectL</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>] &gt; </span><span class="identifier">either</span><span>(</span><span class="identifier">f</span><span>, </span><span class="identifier">g</span><span>) = </span><span class="identifier">f</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">// given
</span><span class="keyword">val</span><span> </span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>

</span><span class="comment">// then
</span><span class="identifier">mapVal</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">f</span><span>) &gt; </span><span class="identifier">neglect</span><span>[</span><span class="type-name">B</span><span>] = </span><span class="identifier">neglect</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
        <p>and many more.</p>
        <p><em>But what does it mean for two Libretto programs to be equal?</em></p>
        <p>Obviously, the sides of the equations above have different source code, so they are not equal at the source code level.</p>
        <p><em>We say that two Libretto programs are equal if their causal dependency graphs are equivalent<sup>(*)</sup>.</em></p>
        <p><sup>(*)</sup> For now let&#39;s settle for some intuitive understanding of <em>causal dependency graphs</em> and a suitable
        equivalence on them. Precise definition is left for further work.</p>
        <p>Note that in the presence of non-determinism arising from concurrency, a single program can have multiple possible
        execution traces. (Again, precise definition of an execution trace is left for further work.)</p>
        <p>A particular implementation of Libretto then determines a probability distribution of the possible execution traces
        of a program.</p>
        <p>Note that it is not required of a Libretto implementation that two equal Libretto programs have the same probability
        distribution of execution traces, only that they have the same set of possible execution traces. In practice this means
        that although two programs are equal, they might exhibit statistically different behaviors.</p>
        <p>Finally, let&#39;s give an example of two programs that look the same on the outside, but are not equal:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">//  ┏━━━━━━━━━━━━━┯━━━━━━━━━━━━━━┓              ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
//  ┞────┐        ╎              ┞────┐         ┞────┐      id[Done]        ┞────┐
//  ╎Done│→┄┄┄┄┐  ╎       ┌┄┄┄┄┄→╎Done│         ╎Done│→┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄→╎Done│
//  ┟────┘     ┆  ├────┐  ┆      ┟────┘         ┟────┘                      ┟────┘
//  ┃    join  ├┄→╎Done│→┄┤ fork ┃         ≠    ┠╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┨
//  ┞────┐     ┆  ├────┘  ┆      ┞────┐         ┞────┐      id[Done]        ┞────┐
//  ╎Done│→┄┄┄┄┘  ╎       └┄┄┄┄┄→╎Done│         ╎Done│→┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄→╎Done│
//  ┟────┘        ╎              ┟────┘         ┟────┘                      ┟────┘
//  ┗━━━━━━━━━━━━━┷━━━━━━━━━━━━━━┛              ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
</span><span>
</span><span class="identifier">join</span><span> &gt; </span><span class="identifier">fork</span><span> ≠ </span><span class="identifier">par</span><span>(</span><span class="identifier">id</span><span>[</span><span class="type-name">Done</span><span>], </span><span class="identifier">id</span><span>[</span><span class="type-name">Done</span><span>])</span></code></pre>
        <p>In the program on the left, each of the output signals depends on both input signals, whereas in the program on the
        right, each output signal depends only on the respective input signal. Clearly, their causal dependency graphs are
        different, and thus the programs are not equal.</p>

      </main>

    </div>

  </body>
</html>